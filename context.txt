<documents>
<document index="1">
<source>.\manage.py</source>
<document_content>
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "bookstore.settings")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()

</document_content>
</document>
<document index="2">
<source>.\auths\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="3">
<source>.\auths\admin.py</source>
<document_content>
from django.contrib import admin

# Register your models here.

</document_content>
</document>
<document index="4">
<source>.\auths\apps.py</source>
<document_content>
from django.apps import AppConfig


class AuthsConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "auths"

</document_content>
</document>
<document index="5">
<source>.\auths\models.py</source>
<document_content>
from django.db import models

# Create your models here.

</document_content>
</document>
<document index="6">
<source>.\auths\tests.py</source>
<document_content>
from django.test import TestCase

# Create your tests here.

</document_content>
</document>
<document index="7">
<source>.\auths\urls.py</source>
<document_content>
from django.urls import path
from . import views

urlpatterns = [
    path("", views.login_view, name="login"),
    path("register/", views.register_view, name="register"),
    path("logout/", views.logout_view, name="logout"),
    path("update-email/", views.update_email, name="update_email"),
    path("change-password/", views.change_password, name="change_password"),
]

</document_content>
</document>
<document index="8">
<source>.\auths\views.py</source>
<document_content>
from django.shortcuts import render, redirect
from django.contrib.auth import authenticate, login, logout
from django.contrib import messages
from django.contrib.auth.models import User
from django.shortcuts import reverse
from core.models.user import User as CustomUser
from django.http import Http404
from django.contrib.auth.decorators import login_required
from core.models.upgrade_request import UpgradeRequest
import re


def _redirect_based_on_role(custom_user):
    """Helper function to redirect users based on their role."""
    role_to_url = {
        "buyer": "buyer-landing",
        "seller": "seller-dashboard",
        "courier": "courier-deliveries",
        "admin": "admin",
    }

    if custom_user.role not in role_to_url:
        raise Http404(
            "Invalid user role. This shouldn't have happened. Find your nearest developer"
        )

    return redirect(reverse(role_to_url[custom_user.role]))


def _check_courier_approval(request, custom_user):
    """Helper function to check if a courier's upgrade request is approved.
    Returns True if the user is approved or not a courier, False otherwise."""
    if custom_user.role == "courier":
        try:
            upgrade_request = UpgradeRequest.objects.get(
                user=custom_user, target_role="courier"
            )
            if not upgrade_request.approved:
                messages.info(
                    request,
                    "Your courier application is still pending approval. Please check back later.",
                )
                return False
        except UpgradeRequest.DoesNotExist:
            messages.warning(
                request,
                "Somehow, you are a courier but don't have an upgrade request. Find your nearest developer.",
            )
            return False
    return True


def validate_password_strength(password):
    """
    Validate that password meets strength requirements:
    - At least 8 characters long
    - Contains at least one uppercase letter
    - Contains at least one lowercase letter
    - Contains at least one number
    - Contains at least one special character
    """
    if len(password) < 8:
        return False
    if not re.search(r'[A-Z]', password):
        return False
    if not re.search(r'[a-z]', password):
        return False
    if not re.search(r'\d', password):
        return False
    if not re.search(r'[!@#$%^&*(),.?":{}|<>]', password):
        return False
    return True


def login_view(request):
    # If user is already authenticated, redirect them to their appropriate page
    if request.user.is_authenticated:
        # Check if user is staff/superuser first
        if request.user.is_staff or request.user.is_superuser:
            return redirect("/admin/")

        try:
            custom_user = CustomUser.objects.get(email=request.user.email)

            if not _check_courier_approval(request, custom_user):
                logout(request)
                return render(request, "login.html")

            return _redirect_based_on_role(custom_user)
        except CustomUser.DoesNotExist:
            messages.error(
                request,
                "Custom user does not exist. This is a logic error and shouldn't have happened. Find your nearest developer",
            )

    if request.method == "POST":
        email = request.POST.get("email")
        password = request.POST.get("password")

        try:
            auth_user = User.objects.get(email=email)
            user = authenticate(request, username=auth_user.username, password=password)
            if user is not None:
                # Check if user is staff/superuser first
                if user.is_staff or user.is_superuser:
                    login(request, user)
                    return redirect("/admin/")

                custom_user = CustomUser.objects.get(email=email)

                if not _check_courier_approval(request, custom_user):
                    return render(request, "login.html")

                login(request, user)
                return _redirect_based_on_role(custom_user)
            else:
                messages.error(request, "Invalid password")
        except User.DoesNotExist:
            messages.error(request, "No account found with this email")
        except CustomUser.DoesNotExist:
            # Check if the user might be a staff/admin user without a CustomUser
            try:
                auth_user = User.objects.get(email=email)
                if auth_user.is_staff or auth_user.is_superuser:
                    user = authenticate(
                        request, username=auth_user.username, password=password
                    )
                    if user is not None:
                        login(request, user)
                        return redirect("/admin/")
                messages.error(request, "Invalid credentials")
            except User.DoesNotExist:
                messages.error(
                    request,
                    "No account found with this email",
                )

    return render(request, "login.html")


def register_view(request):
    if request.method == "POST":
        name = request.POST.get("name")
        email = request.POST.get("email")
        password = request.POST.get("password")
        confirm_password = request.POST.get("confirm_password")
        role = request.POST.get("role")

        if password != confirm_password:
            messages.error(request, "Passwords do not match")
            return render(request, "register.html")

        if not validate_password_strength(password):
            messages.error(request, "Password does not meet strength requirements")
            return render(request, "register.html")

        if User.objects.filter(email=email).exists():
            messages.error(request, "Email already registered")
            return render(request, "register.html")

        try:
            # Create unique username using counter
            username = email.split("@")[0]  # Use part before @ as username
            base_username = username
            counter = 1
            while User.objects.filter(username=username).exists():
                username = f"{base_username}{counter}"
                counter += 1

            # Create built-in user
            auth_user = User.objects.create_user(
                username=username, email=email, password=password
            )

            # Create custom user with role
            custom_user = CustomUser.objects.create(email=email, name=name, role=role)

            # Create upgrade request for courier with approved=False
            if role == "courier":
                UpgradeRequest.objects.create(
                    user=custom_user, target_role="courier", approved=False
                )
                messages.info(
                    request,
                    "Your courier account request has been submitted for review. Please check periodically for approval by signing in.",
                )
                return redirect(reverse("login"))

            user = authenticate(request, username=auth_user.username, password=password)
            if user is not None:
                login(request, user)

                if role == "buyer":
                    return redirect(reverse("buyer-landing"))

            return redirect(reverse("login"))

        except Exception as e:
            messages.error(request, f"Registration failed: {str(e)}")
            return render(request, "register.html")

    return render(request, "register.html")


def logout_view(request):
    logout(request)
    return redirect(reverse("login"))


def _redirect_to_profile(custom_user):
    role_to_url = {
        "buyer": "buyer-profile",
        "seller": "seller-profile",
        "courier": "courier-profile",
        "admin": "admin-profile",
    }
    return redirect(reverse(role_to_url[custom_user.role]))


@login_required
def update_email(request):
    custom_user = CustomUser.objects.get(email=request.user.email)

    if request.method != "POST":
        return _redirect_to_profile(custom_user)

    new_email = request.POST.get("new_email")

    if not new_email:
        messages.error(request, "Please provide a new email address")
        return _redirect_to_profile(custom_user)

    # Check if email is already taken
    if User.objects.exclude(id=request.user.id).filter(email=new_email).exists():
        messages.error(request, "This email is already registered")
        return _redirect_to_profile(custom_user)

    try:
        # Update Django auth user email
        auth_user = request.user
        auth_user.email = new_email
        auth_user.save()

        # Update custom user email
        custom_user.email = new_email
        custom_user.save()

        messages.success(request, "Email updated successfully")
        return _redirect_to_profile(custom_user)
    except Exception as e:
        messages.error(request, f"Failed to update email: {str(e)}")
        return _redirect_to_profile(custom_user)


@login_required
def change_password(request):
    custom_user = CustomUser.objects.get(email=request.user.email)

    if request.method != "POST":
        return _redirect_to_profile(custom_user)

    current_password = request.POST.get("current_password")
    new_password = request.POST.get("new_password")
    confirm_password = request.POST.get("confirm_password")

    if not request.user.check_password(current_password):
        messages.error(request, "Current password is incorrect")
        return _redirect_to_profile(custom_user)

    if new_password != confirm_password:
        messages.error(request, "New passwords do not match")
        return _redirect_to_profile(custom_user)

    try:
        request.user.set_password(new_password)
        request.user.save()
        # Re-authenticate user to prevent logout
        user = authenticate(
            request, username=request.user.username, password=new_password
        )
        if user is not None:
            login(request, user)
            messages.success(request, "Password changed successfully")
            return _redirect_to_profile(custom_user)
    except Exception as e:
        messages.error(request, f"Failed to change password: {str(e)}")
        return _redirect_to_profile(custom_user)

</document_content>
</document>
<document index="9">
<source>.\auths\migrations\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="10">
<source>.\bookstore\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="11">
<source>.\bookstore\asgi.py</source>
<document_content>
"""
ASGI config for bookstore project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "bookstore.settings")

application = get_asgi_application()

</document_content>
</document>
<document index="12">
<source>.\bookstore\settings.py</source>
<document_content>
"""
Django settings for bookstore project.

Generated by 'django-admin startproject' using Django 5.1.5.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from pathlib import Path
import os

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = "django-insecure-gey#f=xuyf-#+grb%y#&&lrzds_wd$*pf2sqdwd_q@t7pp_d8+"

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []

# Application definition

INSTALLED_APPS = [
    "admincharts",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "portal_admin",
    "buyer",
    "seller",
    "courier",
    "core",
    "auths",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "bookstore.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
                "core.context_processors.user_data",
            ],
        },
    },
]

WSGI_APPLICATION = "bookstore.wsgi.application"

# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.sqlite3",
        "NAME": BASE_DIR / "db.sqlite3",
    }
}

# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]

# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "Asia/Kuala_Lumpur"

USE_I18N = True

USE_TZ = True

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = "static/"

STATICFILES_DIRS = [
    os.path.join(BASE_DIR, "static"),
]

MEDIA_URL = "/media/"
MEDIA_ROOT = os.path.join(BASE_DIR, "media")

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

LOGIN_URL = "/"
SESSION_COOKIE_AGE = 600
SESSION_EXPIRE_AT_BROWSER_CLOSE = True

</document_content>
</document>
<document index="13">
<source>.\bookstore\urls.py</source>
<document_content>
"""
URL configuration for bookstore project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.1/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""

from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path("", include("auths.urls")),
    path("admin/", admin.site.urls, name="admin"),
    path("buyer/", include("buyer.urls")),
    path("seller/", include("seller.urls")),
    path("courier/", include("courier.urls")),
]

if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

</document_content>
</document>
<document index="14">
<source>.\bookstore\wsgi.py</source>
<document_content>
"""
WSGI config for bookstore project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "bookstore.settings")

application = get_wsgi_application()

</document_content>
</document>
<document index="15">
<source>.\buyer\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="16">
<source>.\buyer\admin.py</source>
<document_content>
from django.contrib import admin

# Register your models here.

</document_content>
</document>
<document index="17">
<source>.\buyer\apps.py</source>
<document_content>
from django.apps import AppConfig


class BuyerConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "buyer"

</document_content>
</document>
<document index="18">
<source>.\buyer\models.py</source>
<document_content>
from django.db import models

# Create your models here.

</document_content>
</document>
<document index="19">
<source>.\buyer\tests.py</source>
<document_content>
from django.test import TestCase

# Create your tests here.

</document_content>
</document>
<document index="20">
<source>.\buyer\urls.py</source>
<document_content>
"""
URL patterns for buyer app.
"""

from django.urls import path

from buyer.views import book_details_page
from buyer.views import cart_page
from buyer.views import landing_page
from buyer.views import orders_page, checkout_page, order_details_page
from buyer.views import profile_page
from buyer.views.review import submit_review
from buyer.views import upgrade_to_seller

urlpatterns = [
    path("orders/", orders_page, name="buyer-orders"),
    path("checkout/", checkout_page, name="buyer-checkout"),
    path("cart/", cart_page, name="buyer-cart"),
    path("landing/", landing_page, name="buyer-landing"),
    path("orders/<int:order_id>/", order_details_page, name="buyer-order-details"),
    path("book/<int:book_id>/", book_details_page, name="buyer-book-details"),
    path("profile/", profile_page, name="buyer-profile"),
    path("review/<int:shop_id>/", submit_review, name="buyer-review"),
    path("upgrade-to-seller/", upgrade_to_seller, name="buyer-upgrade-to-seller"),
]

</document_content>
</document>
<document index="21">
<source>.\buyer\migrations\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="22">
<source>.\buyer\views\__init__.py</source>
<document_content>
"""
Exposes buyer view functions.
"""

from .book_details import book_details_page
from .cart import cart_page
from .checkout import checkout_page
from .landing import landing_page
from .order_details import order_details_page
from .orders import orders_page
from .profile import profile_page
from .review import submit_review
from .upgrade_to_seller import upgrade_to_seller

</document_content>
</document>
<document index="23">
<source>.\buyer\views\book_details.py</source>
<document_content>
from django.contrib.auth.decorators import login_required
from django.db.models import Avg
from django.shortcuts import get_object_or_404, render, redirect

from core.models import (
    BookListing,
    Cart,
    CartItem,
    User,
    Review,
)
from core.utils.decorators import allowed_roles


@login_required
@allowed_roles(["buyer", "seller"])
def book_details_page(request, book_id):
    """
    View function to display the book details page. This function manages the display of book
    details, allows users to add the book to their shopping cart, calculates the shop's average
    rating based on user reviews, and prepares data for rendering in the template.

    :param request: The HTTP request object.
    :type request: django.http.HttpRequest
    :param book_id: The unique identifier of the book listing.
    :type book_id: int
    :return: Rendered book details page with book, cart, and review context.
    :rtype: django.http.HttpResponse

    """
    current_user = request.user
    authenticated_user = User.objects.get(email=current_user.email)

    book = get_object_or_404(BookListing, id=book_id)
    cart, created = Cart.objects.get_or_create(user=authenticated_user)
    book_in_cart = CartItem.objects.filter(cart=cart, book_listing=book).exists()

    # Get all reviews for the shop selling this book
    shop_reviews = Review.objects.filter(shop=book.shop)

    # Calculate average rating for the shop
    shop_rating_value = shop_reviews.aggregate(Avg("rating"))["rating__avg"]
    if shop_rating_value:
        shop_rating = round(shop_rating_value, 1)
        full_stars = int(shop_rating_value)
        empty_stars = 5 - full_stars
    else:
        shop_rating = 0
        full_stars = 0
        empty_stars = 5

    total_reviews = shop_reviews.count()

    if request.method == "POST":
        # User clicked "Add to Cart"
        #  Check if cart already has items from a different shop
        cart_items = CartItem.objects.filter(cart=cart)
        if cart_items.exists():
            existing_shop = cart_items.first().book_listing.shop
            if existing_shop != book.shop:
                from django.contrib import messages

                messages.error(
                    request, "You can only add books from the same shop to the cart."
                )
                return redirect("buyer-book-details", book_id=book.id)

        if not book_in_cart:
            CartItem.objects.create(cart=cart, book_listing=book)
            return redirect(
                "buyer-book-details", book_id=book.id
            )  # Refresh page after adding

    context = {
        "book": book,
        "book_in_cart": book_in_cart,
        "shop_rating": shop_rating,
        "total_reviews": total_reviews,
        "shop_reviews": shop_reviews,
        # Pass in ranges for iteration in the template:
        "full_stars_list": range(full_stars),
        "empty_stars_list": range(empty_stars),
    }

    return render(request, "buyer/book_details.html", context)

</document_content>
</document>
<document index="24">
<source>.\buyer\views\cart.py</source>
<document_content>
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, redirect, get_object_or_404

from core.models.cart import Cart
from core.models.cart_item import CartItem
from core.utils.decorators import allowed_roles


@login_required
@allowed_roles(["buyer", "seller"])
def cart_page(request):
    """
    Displays the buyer's shopping cart and handles updates and deletions.
    **Handles:**
        - Displays the cart.
        - Removes items from the cart if they have been bought.
    **Context Variables:**
        - ``cart_items``: A queryset of the user's cart items.
        - ``total_price``: The total cost of all items in the cart.
    """

    # Get the logged-in user by email
    current_user = request.user

    # Fetch the cart using the user's email
    try:
        cart = Cart.objects.get(user__email=current_user.email)
        cart_items = CartItem.objects.filter(cart=cart).select_related("book_listing")
    except Cart.DoesNotExist:
        cart = None
        cart_items = CartItem.objects.none()

    # **NEW: Remove books that have already been bought**
    cart_items = cart_items.exclude(book_listing__bought=True)

    # If cart is empty after filtering, set it to an empty list
    if not cart_items.exists():
        cart_items = []

    # Calculate total price
    total_price = sum(item.book_listing.price * item.quantity for item in cart_items)

    if request.method == "POST":
        item_id = request.POST.get("item_id")
        action = request.POST.get("action")

        # Ensure only the logged-in user's cart is affected
        cart_item = get_object_or_404(
            CartItem, id=item_id, cart__user__email=current_user.email
        )

        if action == "remove":
            cart_item.delete()

        return redirect("buyer-cart")  # Refresh cart page after update

    context = {
        "cart_items": cart_items,
        "total_price": total_price,
    }
    return render(request, "buyer/cart.html", context)

</document_content>
</document>
<document index="25">
<source>.\buyer\views\checkout.py</source>
<document_content>
"""
Checkout view for the buyer application.
"""

import re
from decimal import Decimal

from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, redirect
from django.urls import reverse

from core.models.cart import Cart
from core.models.cart_item import CartItem
from core.models.order import Order
from core.models.order_item import OrderItem
from core.models.user import User
from core.utils.decorators import allowed_roles


@login_required
@allowed_roles(["buyer", "seller"])
def checkout_page(request):
    """
    Renders a checkout page and handles order creation upon form submission.

    This view retrieves the currently logged-in user's cart items, displays them for review,
    and upon POST request, creates an Order and corresponding OrderItems, clears the cart,
    updates the book listing to mark it as bought, and redirects to the buyer's orders page.

    :param request: The HTTP request object.
    :type request: django.http.HttpRequest
    :return: Renders the checkout template on GET or redirects to the orders page on successful checkout.
    :rtype: django.http.HttpResponse
    """
    # Get the logged-in user (Django's auth user is our 'User' or you might be bridging them)
    current_user = request.user

    # Attempt to fetch a Cart belonging to this user; if none, context remains empty
    try:
        cart = Cart.objects.get(user__email=current_user.email)
        cart_items = CartItem.objects.select_related("book_listing").filter(cart=cart)
    except Cart.DoesNotExist:
        cart = None
        cart_items = []

    # Calculate subtotal
    subtotal = Decimal("0.00")
    for item in cart_items:
        subtotal += item.book_listing.price * item.quantity

    # We define a simple 6% tax rate to match the bootstrap template
    tax_rate = Decimal("0.06")
    tax_amount = (subtotal * tax_rate).quantize(Decimal("0.01"))
    total_price = (subtotal + tax_amount).quantize(Decimal("0.01"))

    if request.method == "POST":
        # --- Added Address and Payment Details Verification ---

        # Retrieve the address details and payment fields from the POST data
        address = request.POST.get("address", "").strip()
        city = request.POST.get("city", "").strip()
        state = request.POST.get("state", "").strip()
        postal_code = request.POST.get("postal_code", "").strip()
        country = request.POST.get("country", "").strip()
        card_number = request.POST.get("card_number", "").strip()
        expiry_date = request.POST.get("expiry_date", "").strip()
        cvv = request.POST.get("cvv", "").strip()

        # Prepare a context to re-render the checkout page on validation errors.
        error_context = {
            "cart_items": cart_items,
            "subtotal": subtotal,
            "tax_amount": tax_amount,
            "total_price": total_price,
        }

        # Validate Address Details
        if any(char.isdigit() for char in city):
            messages.error(request, "City name should not contain numbers.")
            return render(request, "buyer/checkout.html", error_context)

        if any(char.isdigit() for char in state):
            messages.error(request, "State name should not contain numbers.")
            return render(request, "buyer/checkout.html", error_context)

        if not postal_code.isdigit():
            messages.error(request, "Postal Code must contain only digits.")
            return render(request, "buyer/checkout.html", error_context)

        if any(char.isdigit() for char in country):
            messages.error(request, "Country name should not contain numbers.")
            return render(request, "buyer/checkout.html", error_context)

        # Validate Payment Details
        if (
            not card_number.replace(" ", "").isdigit()
            or len(card_number.replace(" ", "")) != 16
        ):
            messages.error(request, "Card number must be 16 digits.")
            return render(request, "buyer/checkout.html", error_context)

        # Check for MM/YY format (with a valid month from 01 to 12)
        if not re.match(r"^(0[1-9]|1[0-2])\/\d{2}$", expiry_date):
            messages.error(request, "Expiration date must be in MM/YY format.")
            return render(request, "buyer/checkout.html", error_context)

        if not cvv.isdigit() or len(cvv) not in (3, 4):
            messages.error(request, "CVV must be 3 or 4 digits.")
            return render(request, "buyer/checkout.html", error_context)

        # Double-check if the cart still has items before processing
        updated_cart_items = CartItem.objects.filter(cart=cart)
        if not updated_cart_items:
            return redirect(reverse("buyer-checkout"))

        #  Double-check if the cart still has items
        updated_cart_items = CartItem.objects.select_related("book_listing").filter(
            cart=cart
        )
        if not updated_cart_items:
            return redirect(reverse("buyer-checkout"))

        # If any book is already marked as bought, alert the user and stop checkout.
        for item in updated_cart_items:
            if item.book_listing.bought:
                messages.error(
                    request,
                    "One or more books in your cart have already been purchased by another user. Please review your cart.",
                )
                return redirect(reverse("buyer-checkout"))

        # Create a new order with the address details included
        order = Order.objects.create(
            user=User.objects.get(email=current_user.email),
            status="pending",
            total_price=total_price,
            address=address,
            city=city,
            state=state,
            postal_code=postal_code,
            country=country,
        )

        ## Move cart items to order items and mark books as bought (for harris ocd)
        for item in updated_cart_items:
            OrderItem.objects.create(
                order=order,
                book_listing=item.book_listing,
                quantity=item.quantity,
                purchase_price=item.book_listing.price,
            )

            # Mark book as bought
            item.book_listing.bought = True
            item.book_listing.save()

        # Clear the cart
        updated_cart_items.delete()

        # Redirect to buyer_orders page
        return redirect(reverse("buyer-orders"))

    context = {
        "cart_items": cart_items,
        "subtotal": subtotal,
        "tax_amount": tax_amount,
        "total_price": total_price,
    }
    return render(request, "buyer/checkout.html", context)

</document_content>
</document>
<document index="26">
<source>.\buyer\views\landing.py</source>
<document_content>
from django.contrib.auth.decorators import login_required
from django.shortcuts import render

from core.models import User
from core.models.book_listing import BookListing
from core.utils.decorators import allowed_roles


@login_required
@allowed_roles(["buyer", "seller"])
def landing_page(request):
    """
    Renders the Buyer Landing Page with all available books.

    This view retrieves all books that are not bought and displays them in a grid format.

    :param request: The HTTP request object.
    :type request: django.http.HttpRequest
    :return: Rendered landing page with books context.
    :rtype: django.http.HttpResponse
    """
    # Get the logged-in user based on email authentication
    current_user = request.user

    authenticated_user = User.objects.get(email=current_user.email)

    search_query = request.GET.get("q", "").strip()  # Get search term from URL

    # Filter books to only show those that are NOT bought
    if search_query:
        books = BookListing.objects.filter(title__icontains=search_query, bought=False)
    else:
        books = BookListing.objects.filter(bought=False)

    return render(request, "buyer/landing.html", {"books": books})

</document_content>
</document>
<document index="27">
<source>.\buyer\views\order_details.py</source>
<document_content>
"""
Order details view for the buyer application.
"""

from decimal import Decimal
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, get_object_or_404

from core.models.order import Order
from core.models.order_item import OrderItem
from core.utils.decorators import allowed_roles
from core.models.review import Review
from core.models.shop import Shop
from core.models.user import User


@login_required
@allowed_roles(["buyer", "seller"])
def order_details_page(request, order_id):
    """
    Displays detailed information about a specific order, including its items
    and total price breakdown.

    :param request: The HTTP request object.
    :type request: django.http.HttpRequest
    :param order_id: The unique identifier for the order to be displayed.
    :type order_id: int
    :return: Renders the order details template.
    """

    current_user = get_object_or_404(User, email=request.user.email)
    order = get_object_or_404(Order, id=order_id, user=current_user)

    items = OrderItem.objects.filter(order=order)

    # Subtotal, tax, etc.
    subtotal = sum(item.purchase_price * item.quantity for item in items)
    tax_rate = Decimal("0.06")
    tax_amount = (subtotal * tax_rate).quantize(Decimal("0.01"))

    # Distinct shops in this order
    shops_qs = Shop.objects.filter(book_listings__order_items__order=order).distinct()

    # Build a list of (shop, review)
    # Where 'review' is whichever row matches (shop=..., user=current_user)
    shops_with_reviews = []
    for shop in shops_qs:
        # might get .first() or all() if multiple reviews exist
        review = (
            Review.objects.filter(user=current_user, shop=shop)
            .order_by("-created_at")
            .first()
        )
        shops_with_reviews.append((shop, review))

    context = {
        "order": order,
        "items": items,
        "shops_with_reviews": shops_with_reviews,
        "rating_range": [1, 2, 3, 4, 5],
        "subtotal": subtotal,
        "tax_amount": tax_amount,
    }
    return render(request, "buyer/order_details.html", context)

</document_content>
</document>
<document index="28">
<source>.\buyer\views\orders.py</source>
<document_content>
"""
Orders view for the buyer application.
"""

from django.contrib.auth.decorators import login_required
from django.shortcuts import render, get_object_or_404

from core.models.order import Order
from core.utils.decorators import allowed_roles
from core.models.review import Review
from core.models.shop import Shop
from core.models.user import User


@login_required
@allowed_roles(["buyer", "seller"])
def orders_page(request):
    current_user = get_object_or_404(User, email=request.user.email)
    user_orders = Order.objects.filter(user=current_user).order_by("-placed_at")

    for order in user_orders:
        # Gather distinct shops for that order
        shops_qs = Shop.objects.filter(
            book_listings__order_items__order=order
        ).distinct()

        seller_data = []
        for shop in shops_qs:
            # Only check by (user, shop)
            already_reviewed = Review.objects.filter(
                user=current_user, shop=shop
            ).exists()

            seller_data.append({"shop": shop, "already_reviewed": already_reviewed})

        total_sellers = len(seller_data)
        reviewed_count = sum(s["already_reviewed"] for s in seller_data)
        order.all_sellers_reviewed = reviewed_count == total_sellers
        order.seller_info = seller_data

    return render(request, "buyer/orders.html", {"orders": user_orders})

</document_content>
</document>
<document index="29">
<source>.\buyer\views\profile.py</source>
<document_content>
from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from core.models.user import User as CustomUser
from core.utils.decorators import allowed_roles


@login_required
@allowed_roles(["buyer", "seller"])
def profile_page(request):
    custom_user = CustomUser.objects.get(email=request.user.email)

    context = {
        "name": custom_user.name,
        "username": request.user.username,
        "email": request.user.email,
    }

    return render(request, "buyer/profile.html", context)

</document_content>
</document>
<document index="30">
<source>.\buyer\views\review.py</source>
<document_content>
"""
Views for handling review submissions by buyers.
"""

from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.shortcuts import redirect, get_object_or_404

from core.models.order import Order
from core.models.review import Review
from core.models.shop import Shop
from core.models.user import User
from core.utils.decorators import allowed_roles


@login_required
@allowed_roles(["buyer", "seller"])
def submit_review(request, shop_id):
    """

    Creates a Review for (user + shop) if none exists.
    We also verify that the user has at least one COMPLETED order referencing this shop.
    """
    if request.method != "POST":
        messages.error(request, "Invalid request method.")
        return redirect("buyer-orders")

    # Convert the Django auth user to your custom user
    current_user = get_object_or_404(User, email=request.user.email)

    shop = get_object_or_404(Shop, id=shop_id)
    # Check if this user has at least one completed order for that shop
    # We'll look for any Order with 'status=completed' that includes an item from this shop
    completed_orders_for_shop = Order.objects.filter(
        user=current_user,
        status="completed",
        order_items__book_listing__shop=shop,  # or book_listings__shop=shop if your relationships differ
    ).distinct()

    if not completed_orders_for_shop.exists():
        messages.error(
            request,
            "You can only review a shop if you have at least one COMPLETED order with that seller.",
        )
        return redirect("buyer-orders")

    rating_str = request.POST.get("rating")
    comment = request.POST.get("comment", "").strip()

    if not rating_str or not comment:
        messages.error(request, "Please provide both rating and comment.")
        return redirect("buyer-orders")

    try:
        rating = int(rating_str)
    except ValueError:
        messages.error(request, "Invalid rating value.")
        return redirect("buyer-orders")

    # If we find any existing review row for this user+shop, block duplicates
    already_rev = Review.objects.filter(shop=shop, user=current_user).exists()
    if already_rev:
        messages.info(request, "You have already reviewed this seller.")
        return redirect("buyer-orders")

    # Otherwise, create a new row for user + shop
    Review.objects.create(
        shop=shop,
        user=current_user,  # Because your Review model has 'user'
        rating=rating,
        comment=comment,
    )
    messages.success(request, f"Review for {shop.name} submitted successfully!")
    return redirect("buyer-orders")

</document_content>
</document>
<document index="31">
<source>.\buyer\views\upgrade_to_seller.py</source>
<document_content>
from django.shortcuts import redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, reverse
from core.models.upgrade_request import UpgradeRequest
from core.models.user import User as CustomUser
from core.utils.decorators import allowed_roles
from core.models.shop import Shop


def _handle_seller_upgrade_request(request, custom_user):
    """Helper function to handle seller upgrade requests.
    Returns True if a new request was created, False if one already exists."""
    try:
        # Check if user already has a pending upgrade request
        UpgradeRequest.objects.get(user=custom_user, target_role="seller")
        messages.info(
            request,
            "You already have a pending request to become a seller. Please wait for admin approval.",
        )
        return False
    except UpgradeRequest.DoesNotExist:
        # Create new upgrade request
        UpgradeRequest.objects.create(
            user=custom_user, target_role="seller", approved=False
        )
        messages.success(
            request,
            "Your request to become a seller has been submitted. Please check back later for approval status.",
        )
        return True


@login_required
@allowed_roles(["buyer"])
def upgrade_to_seller(request):
    custom_user = CustomUser.objects.get(email=request.user.email)

    if request.method == "GET":
        try:
            upgrade_request = UpgradeRequest.objects.get(
                user=custom_user, target_role="seller"
            )
            if upgrade_request.approved:
                # Update user role to seller if request is approved
                custom_user.role = "seller"
                custom_user.save()

                # Create a default shop for the new seller
                shop_name = f"{custom_user.name}'s Shop"
                Shop.objects.create(name=shop_name, user=custom_user)

                messages.success(
                    request,
                    "Congratulations! Your seller application has been approved. You are now a seller.",
                )
                return redirect(reverse("seller-dashboard"))
            else:
                messages.info(
                    request,
                    "You already have a pending request to become a seller. Please wait for admin approval.",
                )
                return redirect(reverse("buyer-landing"))
        except UpgradeRequest.DoesNotExist:
            pass

    if request.method == "POST":
        _handle_seller_upgrade_request(request, custom_user)
        return redirect(reverse("buyer-landing"))

    return render(request, "buyer/upgrade_to_seller.html")

</document_content>
</document>
<document index="32">
<source>.\core\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="33">
<source>.\core\admin.py</source>
<document_content>
from django.contrib import admin
from django.utils import timezone
from admincharts.admin import AdminChartMixin
from admincharts.utils import months_between_dates
from decimal import Decimal
from core.models import *

# Change admin site title
admin.site.site_header = "booklab administration"
admin.site.site_title = "booklab administration"
admin.site.index_title = "booklab administration"

admin.site.register(UpgradeRequest)
admin.site.register(User)
admin.site.register(OrderAssignment)
admin.site.register(Review)
admin.site.register(Shop)
admin.site.register(Cart)
admin.site.register(CartItem)
admin.site.register(DeliveryIssue)


@admin.register(Order)
class OrderAdmin(AdminChartMixin, admin.ModelAdmin):
    list_chart_type = "line"
    list_chart_options = {"aspectRatio": 6}

    def get_list_chart_data(self, queryset):
        if not queryset:
            return {}

        # Get the earliest order date
        earliest = min(order.placed_at for order in queryset)
        labels = []
        order_counts = []

        # Create a label and count for each month between earliest and now
        for month in months_between_dates(earliest, timezone.now()):
            labels.append(month.strftime("%b %Y"))
            monthly_count = sum(
                1
                for order in queryset
                if order.placed_at.year == month.year
                and order.placed_at.month == month.month
            )
            order_counts.append(monthly_count)

        return {
            "labels": labels,
            "datasets": [
                {
                    "label": "Orders per Month",
                    "data": order_counts,
                    "backgroundColor": "#79aec8",
                },
            ],
        }


@admin.register(OrderItem)
class OrderItemAdmin(AdminChartMixin, admin.ModelAdmin):
    list_chart_type = "bar"
    list_chart_options = {"aspectRatio": 6}

    def get_list_chart_data(self, queryset):
        if not queryset:
            return {}
        # Use the order's placed_at date for aggregation
        earliest = min(oi.order.placed_at for oi in queryset)
        labels = []
        revenue = []
        for month in months_between_dates(earliest, timezone.now()):
            labels.append(month.strftime("%b %Y"))
            monthly_revenue = sum(
                (oi.purchase_price * oi.quantity * Decimal('0.20'))  # Taking 20% of the total purchase price
                for oi in queryset
                if oi.order.placed_at.year == month.year
                and oi.order.placed_at.month == month.month
            )
            revenue.append(float(monthly_revenue))
        return {
            "labels": labels,
            "datasets": [
                {
                    "label": "Revenue per Month",
                    "data": revenue,
                    "backgroundColor": "#36A2EB",
                },
            ],
        }


@admin.register(BookListing)
class BookListingAdmin(AdminChartMixin, admin.ModelAdmin):
    list_chart_type = "pie"
    list_chart_options = {"aspectRatio": 6}

    def get_list_chart_data(self, queryset):
        if not queryset:
            return {}
        condition_counts = {}
        for listing in queryset:
            condition = listing.condition
            condition_counts[condition] = condition_counts.get(condition, 0) + 1
        labels = list(condition_counts.keys())
        counts = list(condition_counts.values())
        colors = ["#FF6384", "#36A2EB", "#FFCE56", "#4BC0C0", "#9966FF"]
        return {
            "labels": labels,
            "datasets": [
                {
                    "label": "Book Listings by Condition",
                    "data": counts,
                    "backgroundColor": colors[: len(counts)],
                },
            ],
        }

</document_content>
</document>
<document index="34">
<source>.\core\apps.py</source>
<document_content>
from django.apps import AppConfig


class CoreConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "core"

</document_content>
</document>
<document index="35">
<source>.\core\constants.py</source>
<document_content>
"""
This file contains predefined choice constraints used across the application models.
These choices ensure consistency and reusability for fields that require fixed options, such as roles,
item conditions, and process statuses.

Definitions:
- ROLE_CHOICES: User roles within the system (e.g., Buyer, Seller).
- CONDITION_CHOICES: Represents item conditions (e.g., Brand New, Used).
- STATUS_CHOICES: Indicates process states (e.g., Pending, Completed).

These choices are typically used in Django model fields via the `choices` argument to enforce valid inputs.
"""

ROLE_CHOICES = [
    ("buyer", "Buyer"),
    ("seller", "Seller"),
    ("admin", "Admin"),
    ("courier", "Courier"),
    ("unassigned", "Unassigned"),
]

CONDITION_CHOICES = [
    ("brand_new", "Brand New"),
    ("like_new", "Like New"),
    ("used", "Used"),
    ("well_used", "Well Used"),
    ("tattered", "Tattered"),
]

STATUS_CHOICES = [
    ("pending", "Pending"),
    ("ready_to_ship", "Ready to Ship"),
    ("shipped", "Shipped"),
    ("completed", "Completed"),
    ("cancelled", "Cancelled"),
]

RATING_CHOICES = [(i, str(i)) for i in range(1, 6)]  # 1 to 5 rating scaler

</document_content>
</document>
<document index="36">
<source>.\core\context_processors.py</source>
<document_content>
from core.models.user import User


def user_data(request):
    """
    Context processor to add user data to all templates
    """
    if request.user.is_authenticated:
        try:
            user = User.objects.get(email=request.user.email)
            return {"custom_user": user}
        except User.DoesNotExist:
            return {}
    return {}

</document_content>
</document>
<document index="37">
<source>.\core\models.py</source>
<document_content>
from django.db import models

# Create your models here.

</document_content>
</document>
<document index="38">
<source>.\core\tests.py</source>
<document_content>
import os
import time

from django.conf import settings
from django.core.exceptions import ValidationError
from django.core.files.uploadedfile import SimpleUploadedFile
from django.db.utils import IntegrityError
from django.test import TestCase

from core.models.book_listing import BookListing
from core.models.cart import Cart
from core.models.cart_item import CartItem
from core.models.delivery_issue import DeliveryIssue
from core.models.order import Order
from core.models.order_assignment import OrderAssignment
from core.models.order_item import OrderItem
from core.models.review import Review
from core.models.shop import Shop
from core.models.upgrade_request import UpgradeRequest
from core.models.user import User


# Create your tests here.


class UserModelTest(TestCase):
    """Tests for the User model

    Test Cases:
    - Successful creation of a user with an email, name, and role.
    - Validation to ensure a user must have an email.
    - Validation to ensure a user must have a name.
    - Verification that the default role is 'buyer' when no role is specified.
    - Constraint enforcement ensuring emails are unique.
    - Validation to ensure that only allowed roles can be assigned to a user.
    - String representation of a user should return the email.
    """

    def setUp(self):
        """Create a sample user for testing"""
        self.user = User.objects.create(
            email="testuser@example.com", name="Test User", role="buyer"
        )

    def test_user_creation(self):
        """Test if a user is created successfully."""
        self.assertEqual(self.user.email, "testuser@example.com")
        self.assertEqual(self.user.name, "Test User")
        self.assertEqual(self.user.role, "buyer")

    def test_email_required(self):
        """Test that a user must have an email."""
        user = User(name="No Email", role="seller")
        with self.assertRaises(ValidationError):
            user.full_clean()

    def test_default_role(self):
        """Test that the default role is 'buyer'."""
        new_user = User.objects.create(email="new@example.com", name="New User")
        self.assertEqual(new_user.role, "buyer")

    def test_unique_email(self):
        """Test that emails must be unique."""
        with self.assertRaises(IntegrityError):
            User.objects.create(
                email="testuser@example.com", name="Duplicate User", role="seller"
            )

    def test_name_required(self):
        """Test that a user must have a name."""
        user = User(email="no_name@example.com", role="buyer")
        with self.assertRaises(ValidationError):
            user.full_clean()

    def test_invalid_role(self):
        """Test that an invalid role is not allowed."""
        user = User(
            email="invalid_role@example.com", name="Test User", role="invalid_role"
        )
        with self.assertRaises(ValidationError):
            user.full_clean()

    def test_user_str(self):
        """Test the user string representation."""
        self.assertEqual(str(self.user), self.user.email)


class ShopModelTest(TestCase):
    """
    Test case for testing the Shop model.

    Test Cases:
    - Successful creation of a shop with a name and associated user.
    - Validation to ensure a shop must have a name.
    - Validation to ensure a shop must be linked to a user.
    - Verification of the shop's string representation.
    - Constraint enforcement to ensure that deleting a user also deletes their shop (CASCADE).
    - Validation to ensure a user can own multiple shops.
    """

    def setUp(self):
        """Create a sample user for testing"""
        self.user = User.objects.create(
            email="seller@example.com", name="Seller User", role="seller"
        )

    def test_shop_creation(self):
        """Test if a shop is created successfully."""
        shop = Shop.objects.create(name="My Bookstore", user=self.user)
        self.assertEqual(shop.name, "My Bookstore")
        self.assertEqual(shop.user, self.user)

    def test_name_required(self):
        """Test that a shop must have a name."""
        shop = Shop(user=self.user)
        with self.assertRaises(ValidationError):
            shop.full_clean()

    def test_shop_must_have_user(self):
        """Test that a shop must be linked to a user."""
        shop = Shop(name="No Owner Shop", user=None)
        with self.assertRaises(ValidationError):
            shop.full_clean()

    def test_shop_string_representation(self):
        """Test the shop string representation."""
        shop = Shop.objects.create(name="My Bookstore", user=self.user)
        self.assertEqual(str(shop), "My Bookstore")

    def test_deleting_user_deletes_shop(self):
        """Test that deleting a user also deletes their shop (CASCADE)"""
        shop = Shop.objects.create(name="My Bookstore", user=self.user)
        self.user.delete()

        with self.assertRaises(Shop.DoesNotExist):
            Shop.objects.get(id=shop.id)

    def test_user_can_have_multiple_shops(self):
        """Test that a user can own multiple shops"""
        shop1 = Shop.objects.create(name="Shop 1", user=self.user)
        shop2 = Shop.objects.create(name="Shop 2", user=self.user)

        self.assertEqual(self.user.shops.count(), 2)  # Check total shops
        self.assertIn(shop1, self.user.shops.all())  # Verify shop1 is in queryset
        self.assertIn(shop2, self.user.shops.all())  # Verify shop2 is in queryset


class CartModelTest(TestCase):
    """
    A test case for validating the Cart model functionality in a Django application.

    Test Cases:
    - Successful creation of a cart associated with a user.
    - Validation to ensure a cart must be linked to a user.
    - Constraint enforcement to ensure that deleting a user also deletes their cart (CASCADE).
    - Validation to ensure carts are retrieved in the order they were created.
    - Verification that a user can have multiple carts.
    - Verification of the cart's string representation.
    """

    def setUp(self):
        """Create a sample user for testing"""
        self.user = User.objects.create(
            email="buyer@example.com", name="Buyer User", role="buyer"
        )

    def test_cart_creation(self):
        """Test if a cart is created successfully."""
        cart = Cart.objects.create(user=self.user)
        self.assertEqual(cart.user, self.user)
        self.assertIsNotNone(cart.created_at)  # Ensure timestamp is set

    def test_cart_must_have_user(self):
        """Test that a cart must be linked to a user."""
        cart = Cart(user=None)
        with self.assertRaises(ValidationError):
            cart.full_clean()

    def test_deleting_user_deletes_cart(self):
        """Test that deleting a user also deletes their cart (CASCADE)"""
        cart = Cart.objects.create(user=self.user)
        self.user.delete()

        with self.assertRaises(Cart.DoesNotExist):  # The cart should be gone
            Cart.objects.get(id=cart.id)

    def test_carts_are_ordered_by_creation_date(self):
        """Test that carts are retrieved in the order they were created"""
        cart1 = Cart.objects.create(user=self.user)
        cart2 = Cart.objects.create(user=self.user)

        carts = list(Cart.objects.filter(user=self.user).order_by("created_at"))
        self.assertEqual(carts, [cart1, cart2])  # Verify correct order

    def test_user_can_have_multiple_carts(self):
        """Test that a user can have multiple carts"""
        cart1 = Cart.objects.create(user=self.user)
        cart2 = Cart.objects.create(user=self.user)

        self.assertEqual(self.user.carts.count(), 2)  # Check total carts
        self.assertIn(cart1, self.user.carts.all())  # Verify cart1 exists
        self.assertIn(cart2, self.user.carts.all())  # Verify cart2 exists

    def test_cart_str_representation(self):
        """Test the cart string representation"""
        cart = Cart.objects.create(user=self.user)
        self.assertEqual(str(cart), f"Cart {cart.id} for {self.user.email}")


class OrderModelTest(TestCase):
    """
    Test case suite for testing the `Order` model.

     Test Cases:
    - Successful creation of an order with an associated user and total price.
    - Validation to ensure an order must be linked to a user.
    - Verification that the default status of an order is 'pending'.
    - Constraint enforcement to ensure that deleting a user also deletes their orders (CASCADE).
    - Verification that an order's timestamp is correctly set upon creation.

    """

    def setUp(self):
        """Create a sample user for testing"""
        self.user = User.objects.create(
            email="buyer@example.com", name="Buyer User", role="buyer"
        )

    def test_order_creation_with_address(self):
        """Test if an order is created successfully with an address."""
        order = Order.objects.create(
            user=self.user,
            total_price=100.50,
            address="123 Bookstore street",
            city="Ahhhh",
            state="Kedah",
            postal_code="80085",
            country="Malaysia",
        )
        self.assertEqual(order.user, self.user)
        self.assertEqual(order.address, "123 Bookstore street")
        self.assertEqual(order.city, "Ahhhh")
        self.assertEqual(order.state, "Kedah")
        self.assertEqual(order.postal_code, "80085")
        self.assertEqual(order.country, "Malaysia")
        self.assertEqual(order.status, "pending")  # Default status
        self.assertIsNotNone(order.placed_at)  # Ensure timestamp is set

        def test_order_must_have_address(self):
            """Test that an order must have an address and related fields."""
            order = Order(
                user=self.user,
                total_price=50.00,
                address="",  # Empty address should fail
                city="",
                state="",
                postal_code="",
                country="",
            )
            with self.assertRaises(ValidationError):
                order.full_clean()

    def test_order_must_have_user(self):
        """Test that an order must be linked to a user."""
        order = Order(user=None, total_price=50.00)
        with self.assertRaises(ValidationError):
            order.full_clean()

    def test_order_default_status(self):
        """Test that the default order status is 'pending'."""
        order = Order.objects.create(
            user=self.user,
            total_price=75.00,
            address="Harris's house",
            city="IDFK",
            state="Putrajaya",
            postal_code="420420",
            country="Malaysia",
        )
        self.assertEqual(order.status, "pending")

    def test_deleting_user_deletes_order(self):
        """Test that deleting a user also deletes their orders (CASCADE)"""
        order = Order.objects.create(
            user=self.user,
            total_price=150.00,
            address="Another Harris's house",
            city="FapCity",
            state="Selangor",
            postal_code="6969",
            country="Malaysia",
        )
        self.user.delete()

        with self.assertRaises(Order.DoesNotExist):  # The order should be gone
            Order.objects.get(id=order.id)


class UpgradeRequestModelTest(TestCase):
    """Tests for the UpgradeRequestModel

    Test Cases:
    - Successful creation of an upgrade request with an associated user and target role.
    - Validation to ensure an upgrade request must be linked to a user.
    - Validation to ensure an upgrade request has a valid target role.
    - Constraint enforcement to ensure that deleting a user also deletes their upgrade requests (CASCADE).
    - Verification that an upgrade request's timestamp is correctly set upon creation.
    - Verification that an upgrade request's approved field defaults to False.
    - Verification that an upgrade request's approved field can be updated.
    """

    def setUp(self):
        """Create a sample user for testing"""
        self.user = User.objects.create(
            email="user@example.com", name="Test User", role="buyer"
        )

    def test_upgrade_request_creation(self):
        """Test if an upgrade request is created successfully."""
        request = UpgradeRequest.objects.create(user=self.user, target_role="seller")
        self.assertEqual(request.user, self.user)
        self.assertEqual(request.target_role, "seller")
        self.assertIsNotNone(request.requested_at)  # Ensure timestamp is set
        self.assertFalse(request.approved)  # Ensure approved defaults to False

    def test_upgrade_request_must_have_user(self):
        """Test that an upgrade request must be linked to a user."""
        request = UpgradeRequest(user=None, target_role="seller")
        with self.assertRaises(ValidationError):
            request.full_clean()

    def test_upgrade_request_must_have_valid_role(self):
        """Test that an upgrade request must have a valid role."""
        request = UpgradeRequest(user=self.user, target_role="invalid_role")
        with self.assertRaises(ValidationError):
            request.full_clean()

    def test_deleting_user_deletes_upgrade_request(self):
        """Test that deleting a user al so deletes their upgrade requests (CASCADE)"""
        request = UpgradeRequest.objects.create(user=self.user, target_role="seller")
        self.user.delete()

        with self.assertRaises(
            UpgradeRequest.DoesNotExist
        ):  # The request should be gone
            UpgradeRequest.objects.get(id=request.id)

    def test_upgrade_request_approval(self):
        """Test that an upgrade request can be approved."""
        request = UpgradeRequest.objects.create(user=self.user, target_role="seller")
        self.assertFalse(request.approved)  # Initially not approved

        # Approve the request
        request.approved = True
        request.save()

        # Refresh from database and verify
        request.refresh_from_db()
        self.assertTrue(request.approved)

    def test_upgrade_request_default_not_approved(self):
        """Test that a new upgrade request is not approved by default."""
        request = UpgradeRequest.objects.create(user=self.user, target_role="seller")
        self.assertFalse(request.approved)

        # Verify even after refresh
        request.refresh_from_db()
        self.assertFalse(request.approved)


class BookListingModelTest(TestCase):
    """Tests for the BookListingModel functionality.

    This test suite verifies the creation, validation, and deletion behavior of the
    BookListing model in relation to shops. It ensures that listings are created
    correctly, validations function as expected for required attributes, and cascading
    deletions work as intended when a related shop is removed.

    Test Cases:
    - Book listing creation and proper linking to a shop.
    - Required relation between book listings and shops.
    - Validation of acceptable book condition values.
    - Cascading deletion of book listings when their related shop is deleted.
    """

    def setUp(self):
        """Create a sample shop for testing"""
        self.user = User.objects.create(
            email="seller@example.com", name="Seller", role="seller"
        )
        self.shop = Shop.objects.create(name="Book Haven", user=self.user)

    def test_book_listing_creation(self):
        """Test if a book listing is created successfully."""
        listing = BookListing.objects.create(
            shop=self.shop,
            title="Django for Beginners",
            author="William S. Vincent",
            condition="good",
            price=29.99,
        )
        self.assertEqual(listing.shop, self.shop)
        self.assertEqual(listing.title, "Django for Beginners")
        self.assertEqual(listing.condition, "good")

    def test_book_listing_must_have_shop(self):
        """Test that a book listing must be linked to a shop."""
        listing = BookListing(
            title="No Shop Book", author="Unknown", condition="fair", price=10.00
        )
        with self.assertRaises(ValidationError):
            listing.full_clean()

    def test_book_listing_must_have_valid_condition(self):
        """Test that a book listing must have a valid condition."""
        listing = BookListing(
            shop=self.shop,
            title="Invalid Condition Book",
            author="Fake",
            condition="bad",
            price=5.00,
        )
        with self.assertRaises(ValidationError):
            listing.full_clean()

    def test_deleting_shop_deletes_book_listings(self):
        """Test that deleting a shop also deletes its book listings (CASCADE)"""
        listing = BookListing.objects.create(
            shop=self.shop,
            title="Python Basics",
            author="John Doe",
            condition="new",
            price=19.99,
        )
        self.shop.delete()

        with self.assertRaises(BookListing.DoesNotExist):  # The listing should be gone
            BookListing.objects.get(id=listing.id)

    def test_book_listing_image_assignment(self):
        """Test that a book listing can be created with an image file."""
        with open(os.path.join(settings.MEDIA_ROOT, "test_img.jpg"), "rb") as f:
            image_data = f.read()

        image_file = SimpleUploadedFile(
            "test_img.jpg", image_data, content_type="image/jpeg"
        )
        listing = BookListing.objects.create(
            shop=self.shop,
            title="Test Image Book",
            author="Image Author",
            condition="used",
            price=15.00,
            image=image_file,
        )

        try:
            self.assertIsNotNone(listing.image)
            # Check that the uploaded image file's name includes 'test_img' and ends with '.jpg'
            self.assertIn("test_img", listing.image.name)
            self.assertTrue(listing.image.name.endswith(".jpg"))
        finally:
            # Clean up: Delete the uploaded image file from the file system
            if listing.image and os.path.exists(listing.image.path):
                os.remove(listing.image.path)

    def test_book_listing_without_image(self):
        """Test that a book listing created without an image remains with an empty image field."""
        listing = BookListing.objects.create(
            shop=self.shop,
            title="Test No Image Book",
            author="No Image Author",
            condition="tattered",
            price=20.00,
        )
        # If no image is uploaded, the field should be empty (evaluates to False)
        self.assertFalse(listing.image)


class ReviewModelTest(TestCase):
    """Tests for the ReviewModel functionality.

    This test suite verifies the creation, validation, and deletion behavior of the
    Review model. It ensures that reviews are created correctly, validations function
    as expected for required attributes and constraints, and cascading deletions
    work as intended when a related shop or user is removed.

    Test Cases:
    - Creation of a review and proper linking to a shop and user.
    - Validation of the rating to ensure it falls between acceptable range (1-5).
    - Validation that reviews are linked to both a shop and a user.
    - Cascading deletion of reviews when their related shop is deleted.
    - Cascading deletion of reviews when the associated user is deleted.
    """

    def setUp(self):
        """Create a sample shop and user for testing"""
        self.user = User.objects.create(
            email="buyer@example.com", name="Buyer User", role="buyer"
        )
        self.shop = Shop.objects.create(name="Tech Haven", user=self.user)

    def test_review_creation(self):
        """Test if a review is created successfully."""
        review = Review.objects.create(
            shop=self.shop, user=self.user, rating=5, comment="Excellent service!"
        )
        self.assertEqual(review.shop, self.shop)
        self.assertEqual(review.user, self.user)
        self.assertEqual(review.rating, 5)

    def test_review_must_have_valid_rating(self):
        """Test that a review must have a rating between 1 and 5."""
        review = Review(shop=self.shop, user=self.user, rating=6, comment="Too high")
        with self.assertRaises(ValidationError):
            review.full_clean()

        review.rating = 0  # Too low
        with self.assertRaises(ValidationError):
            review.full_clean()

    def test_review_must_have_shop_and_user(self):
        """Test that a review must be linked to a shop and user."""
        review = Review(shop=None, user=self.user, rating=3, comment="No shop linked")
        with self.assertRaises(ValidationError):
            review.full_clean()

        review = Review(shop=self.shop, user=None, rating=3, comment="No user linked")
        with self.assertRaises(ValidationError):
            review.full_clean()

    def test_deleting_shop_deletes_reviews(self):
        """Test that deleting a shop also deletes its reviews (CASCADE)"""
        review = Review.objects.create(
            shop=self.shop, user=self.user, rating=4, comment="Great products!"
        )
        self.shop.delete()

        with self.assertRaises(Review.DoesNotExist):  # The review should be gone
            Review.objects.get(id=review.id)

    def test_deleting_user_deletes_reviews(self):
        """Test that deleting a user also deletes their reviews (CASCADE)"""
        review = Review.objects.create(
            shop=self.shop, user=self.user, rating=5, comment="Amazing!"
        )
        self.user.delete()

        with self.assertRaises(Review.DoesNotExist):  # The review should be gone
            Review.objects.get(id=review.id)


class CartItemModelTest(TestCase):
    """Tests for the CartItemModel functionality.

    This test suite verifies the creation, validation, and deletion behavior of the
    CartItem model. It ensures that cart items are properly linked to both carts and
    book listings, validates constraints such as required relationships and positive
    quantities, and checks cascading deletion behavior for associated carts and book listings.

    Test Cases:
    - Successful creation of a cart item linked to a cart and book listing.
    - Validation to ensure cart items are linked to both a cart and a book listing.
    - Validation to ensure cart items have a positive quantity.
    - Cascading deletion of cart items when their associated cart is deleted.
    - Cascading deletion of cart items when their associated book listing is deleted.
    """

    def setUp(self):
        """Create a sample cart and book listing for testing"""
        self.user = User.objects.create(
            email="buyer@example.com", name="Buyer User", role="buyer"
        )
        self.cart = Cart.objects.create(user=self.user)

        self.shop = Shop.objects.create(name="Bookstore", user=self.user)
        self.book_listing = BookListing.objects.create(
            shop=self.shop,
            title="Django for Beginners",
            author="William S. Vincent",
            condition="good",
            price=29.99,
        )

    def test_cart_item_creation(self):
        """Test if a cart item is created successfully."""
        cart_item = CartItem.objects.create(
            cart=self.cart, book_listing=self.book_listing, quantity=2
        )
        self.assertEqual(cart_item.cart, self.cart)
        self.assertEqual(cart_item.book_listing, self.book_listing)
        self.assertEqual(cart_item.quantity, 2)

    def test_cart_item_must_have_cart_and_book_listing(self):
        """Test that a cart item must be linked to a cart and a book listing."""
        cart_item = CartItem(cart=None, book_listing=self.book_listing, quantity=1)
        with self.assertRaises(ValidationError):
            cart_item.full_clean()

        cart_item = CartItem(cart=self.cart, book_listing=None, quantity=1)
        with self.assertRaises(ValidationError):
            cart_item.full_clean()

    def test_cart_item_must_have_positive_quantity(self):
        """Test that a cart item must have a positive quantity."""
        cart_item = CartItem(
            cart=self.cart, book_listing=self.book_listing, quantity=-1
        )
        with self.assertRaises(ValidationError):
            cart_item.full_clean()

        cart_item.quantity = 0
        with self.assertRaises(ValidationError):
            cart_item.full_clean()

    def test_deleting_cart_deletes_cart_items(self):
        """Test that deleting a cart also deletes its cart items (CASCADE)"""
        cart_item = CartItem.objects.create(
            cart=self.cart, book_listing=self.book_listing, quantity=1
        )
        self.cart.delete()

        with self.assertRaises(CartItem.DoesNotExist):  # The cart item should be gone
            CartItem.objects.get(id=cart_item.id)

    def test_deleting_book_listing_deletes_cart_items(self):
        """Test that deleting a book listing also deletes its cart items (CASCADE)"""
        cart_item = CartItem.objects.create(
            cart=self.cart, book_listing=self.book_listing, quantity=1
        )
        self.book_listing.delete()

        with self.assertRaises(CartItem.DoesNotExist):  # The cart item should be gone
            CartItem.objects.get(id=cart_item.id)


class OrderItemModelTest(TestCase):
    """Tests for the OrderItemModel functionality.

    This test suite validates the creation, constraints, and deletion behavior of the
    OrderItem model. It ensures that order items are properly linked to an order and
    a book listing, enforces constraints such as positive quantities and purchase prices,
    and verifies cascading deletions for related orders and book listings.

    Test Cases:
    - Successful creation of an order item linked to an order and a book listing.
    - Validation to ensure order items are linked to both an order and a book listing.
    - Validation to ensure order items have positive quantities.
    - Validation to ensure order items have positive purchase prices.
    - Verification of cascading deletion of order items when their associated order is deleted.
    - Verification of cascading deletion of order items when their associated book listing is deleted.
    """

    def setUp(self):
        """Create a sample order and book listing for testing"""
        self.user = User.objects.create(
            email="buyer@example.com", name="Buyer User", role="buyer"
        )
        self.order = Order.objects.create(user=self.user, total_price=100.00)

        self.shop = Shop.objects.create(name="Bookstore", user=self.user)
        self.book_listing = BookListing.objects.create(
            shop=self.shop,
            title="Django for Beginners",
            author="William S. Vincent",
            condition="good",
            price=29.99,
        )

    def test_order_item_creation(self):
        """Test if an order item is created successfully."""
        order_item = OrderItem.objects.create(
            order=self.order,
            book_listing=self.book_listing,
            quantity=2,
            purchase_price=29.99,
        )
        self.assertEqual(order_item.order, self.order)
        self.assertEqual(order_item.book_listing, self.book_listing)
        self.assertEqual(order_item.quantity, 2)
        self.assertEqual(order_item.purchase_price, 29.99)

    def test_order_item_must_have_order_and_book_listing(self):
        """Test that an order item must be linked to an order and a book listing."""
        order_item = OrderItem(
            order=None, book_listing=self.book_listing, quantity=1, purchase_price=20.00
        )
        with self.assertRaises(ValidationError):
            order_item.full_clean()

        order_item = OrderItem(
            order=self.order, book_listing=None, quantity=1, purchase_price=20.00
        )
        with self.assertRaises(ValidationError):
            order_item.full_clean()

    def test_order_item_must_have_positive_quantity(self):
        """Test that an order item must have a positive quantity."""
        order_item = OrderItem(
            order=self.order,
            book_listing=self.book_listing,
            quantity=-1,
            purchase_price=20.00,
        )
        with self.assertRaises(ValidationError):
            order_item.full_clean()

        order_item.quantity = 0
        with self.assertRaises(ValidationError):
            order_item.full_clean()

    def test_order_item_must_have_positive_purchase_price(self):
        """Test that an order item must have a positive purchase price."""
        order_item = OrderItem(
            order=self.order,
            book_listing=self.book_listing,
            quantity=1,
            purchase_price=-5.00,
        )
        with self.assertRaises(ValidationError):
            order_item.full_clean()

        order_item.purchase_price = 0
        with self.assertRaises(ValidationError):
            order_item.full_clean()

    def test_deleting_order_deletes_order_items(self):
        """Test that deleting an order also deletes its order items (CASCADE)"""
        order_item = OrderItem.objects.create(
            order=self.order,
            book_listing=self.book_listing,
            quantity=1,
            purchase_price=29.99,
        )
        self.order.delete()

        with self.assertRaises(OrderItem.DoesNotExist):  # The order item should be gone
            OrderItem.objects.get(id=order_item.id)

    def test_deleting_book_listing_deletes_order_items(self):
        """Test that deleting a book listing also deletes its order items (CASCADE)"""
        order_item = OrderItem.objects.create(
            order=self.order,
            book_listing=self.book_listing,
            quantity=1,
            purchase_price=29.99,
        )
        self.book_listing.delete()

        with self.assertRaises(OrderItem.DoesNotExist):  # The order item should be gone
            OrderItem.objects.get(id=order_item.id)


class OrderAssignmentModelTest(TestCase):
    """Tests for the OrderAssignmentModel functionality.

        This test suite validates the creation, constraints, and deletion behavior of the
        OrderAssignment model. It ensures that order assignments are properly linked to
        both an order and a courier, enforces constraints such as uniqueness of assignments
        per order, and verifies cascading deletions of assignments when their related orders
        or couriers are deleted.

    Test Cases:
    - Successful creation of an order assignment linked to an order and a courier.
    - Validation to ensure order assignments are linked to both an order and a courier.
    - Validation to ensure that an order can have only one assignment.
    - Verification of cascading deletion of assignments when their associated order is deleted.
    - Verification of cascading deletion of assignments when their associated courier is deleted.
    """

    def setUp(self):
        """Create a sample order and courier user for testing"""
        self.courier = User.objects.create(
            email="courier@example.com", name="Courier User", role="courier"
        )
        self.user = User.objects.create(
            email="buyer@example.com", name="Buyer User", role="buyer"
        )
        self.order = Order.objects.create(user=self.user, total_price=150.00)

    def test_order_assignment_creation(self):
        """Test if an order assignment is created successfully."""
        assignment = OrderAssignment.objects.create(
            order=self.order, courier=self.courier
        )
        self.assertEqual(assignment.order, self.order)
        self.assertEqual(assignment.courier, self.courier)
        self.assertIsNotNone(assignment.assigned_at)

    def test_order_assignment_must_have_order_and_courier(self):
        """Test that an order assignment must be linked to an order and a courier."""
        assignment = OrderAssignment(order=None, courier=self.courier)
        with self.assertRaises(ValidationError):
            assignment.full_clean()

        assignment = OrderAssignment(order=self.order, courier=None)
        with self.assertRaises(ValidationError):
            assignment.full_clean()

    def test_order_can_have_only_one_assignment(self):
        """Test that an order can have only one assignment."""
        OrderAssignment.objects.create(order=self.order, courier=self.courier)

        with self.assertRaises(ValidationError):
            duplicate_assignment = OrderAssignment(
                order=self.order, courier=self.courier
            )
            duplicate_assignment.full_clean()

    def test_deleting_order_deletes_assignment(self):
        """Test that deleting an order also deletes its assignment (CASCADE)"""
        assignment = OrderAssignment.objects.create(
            order=self.order, courier=self.courier
        )
        self.order.delete()

        with self.assertRaises(OrderAssignment.DoesNotExist):
            OrderAssignment.objects.get(id=assignment.id)

    def test_deleting_courier_deletes_assignment(self):
        """Test that deleting a courier also deletes their assignments (CASCADE)"""
        assignment = OrderAssignment.objects.create(
            order=self.order, courier=self.courier
        )
        self.courier.delete()

        with self.assertRaises(OrderAssignment.DoesNotExist):
            OrderAssignment.objects.get(id=assignment.id)

    # --- Add the following tests for the `updated_at` field below ---

    def test_updated_at_auto_set_on_creation(self):
        """
        Test that `updated_at` is automatically set upon creation.
        Because `auto_now` is used, on creation `updated_at` should have a value,
        and it should be almost identical to `assigned_at` (the difference being negligible).
        """
        assignment = OrderAssignment.objects.create(
            order=self.order, courier=self.courier
        )
        self.assertIsNotNone(assignment.updated_at)
        # Check that assigned_at and updated_at are almost the same at creation time.
        self.assertAlmostEqual(
            assignment.assigned_at.timestamp(),
            assignment.updated_at.timestamp(),
            delta=1,  # Allowing a one-second difference
        )

    def test_updated_at_auto_update_on_save(self):
        """
        Test that `updated_at` is automatically updated when the model is saved.
        We simulate an update by waiting briefly and then saving the instance again.
        """
        assignment = OrderAssignment.objects.create(
            order=self.order, courier=self.courier
        )
        old_updated_at = assignment.updated_at
        # Pause for a second to ensure a timestamp difference.
        time.sleep(1)
        # Save the instance to trigger the auto_now update.
        assignment.save()
        assignment.refresh_from_db()
        new_updated_at = assignment.updated_at
        self.assertGreater(new_updated_at, old_updated_at)


class DeliveryIssueModelTest(TestCase):
    """Tests for the DeliveryIssueModel functionality.

    This test suite validates the creation, constraints, and deletion behavior of the
    DeliveryIssue model. It ensures that delivery issues are properly linked to
    order assignments, enforce constraints such as mandatory descriptions and assignments,
    and verify cascading deletions of delivery issues when their related order assignments are deleted.

    Test Cases:
    - Successful creation of a delivery issue linked to an order assignment.
    - Validation to ensure delivery issues are linked to an order assignment.
    - Validation to ensure delivery issues have a mandatory description.
    - Validation to ensure order assignments can have only one associated delivery issue.
    - Verification of cascading deletion of a delivery issue when its related order assignment is deleted.
    """

    def setUp(self):
        """Create a sample order, courier user, and order assignment for testing"""
        self.courier = User.objects.create(
            email="courier@example.com", name="Courier User", role="courier"
        )
        self.user = User.objects.create(
            email="buyer@example.com", name="Buyer User", role="buyer"
        )
        self.order = Order.objects.create(user=self.user, total_price=150.00)
        self.assignment = OrderAssignment.objects.create(
            order=self.order, courier=self.courier
        )

    def test_delivery_issue_creation(self):
        """Test if a delivery issue is created successfully."""
        issue = DeliveryIssue.objects.create(
            order_assignment=self.assignment, issue_description="Package was damaged"
        )
        self.assertEqual(issue.order_assignment, self.assignment)
        self.assertEqual(issue.issue_description, "Package was damaged")
        self.assertIsNotNone(issue.reported_at)

    def test_delivery_issue_must_have_order_assignment(self):
        """Test that a delivery issue must be linked to an order assignment."""
        issue = DeliveryIssue(order_assignment=None, issue_description="Package lost")
        with self.assertRaises(ValidationError):
            issue.full_clean()

    def test_delivery_issue_must_have_description(self):
        """Test that a delivery issue must have a description."""
        issue = DeliveryIssue(order_assignment=self.assignment, issue_description="")
        with self.assertRaises(ValidationError):
            issue.full_clean()

    def test_order_assignment_can_have_only_one_issue(self):
        """Test that an order assignment can have only one delivery issue."""
        DeliveryIssue.objects.create(
            order_assignment=self.assignment, issue_description="Delayed delivery"
        )

        with self.assertRaises(ValidationError):
            duplicate_issue = DeliveryIssue(
                order_assignment=self.assignment, issue_description="Another issue"
            )
            duplicate_issue.full_clean()

    def test_deleting_order_assignment_deletes_delivery_issue(self):
        """Test that deleting an order assignment also deletes its issue (CASCADE)"""
        issue = DeliveryIssue.objects.create(
            order_assignment=self.assignment, issue_description="Late delivery"
        )
        self.assignment.delete()

        with self.assertRaises(DeliveryIssue.DoesNotExist):  # The issue should be gone
            DeliveryIssue.objects.get(id=issue.id)

</document_content>
</document>
<document index="39">
<source>.\core\views.py</source>
<document_content>
from django.shortcuts import render

# Create your views here.

</document_content>
</document>
<document index="40">
<source>.\core\migrations\0001_initial.py</source>
<document_content>
# Generated by Django 5.1.5 on 2025-02-08 14:21

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="BookListing",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("title", models.CharField(max_length=255)),
                ("author", models.CharField(max_length=255)),
                (
                    "condition",
                    models.CharField(
                        choices=[
                            ("brand_new", "Brand New"),
                            ("like_new", "Like New"),
                            ("used", "Used"),
                            ("well_used", "Well Used"),
                            ("tattered", "Tattered"),
                        ],
                        max_length=50,
                    ),
                ),
                ("price", models.DecimalField(decimal_places=2, max_digits=10)),
                (
                    "image",
                    models.ImageField(blank=True, null=True, upload_to="book_images/"),
                ),
                ("bought", models.BooleanField(default=False)),
            ],
        ),
        migrations.CreateModel(
            name="Cart",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("created_at", models.DateTimeField(auto_now_add=True)),
            ],
        ),
        migrations.CreateModel(
            name="Order",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "status",
                    models.CharField(
                        choices=[
                            ("pending", "Pending"),
                            ("ready_to_ship", "Ready to Ship"),
                            ("shipped", "Shipped"),
                            ("completed", "Completed"),
                            ("cancelled", "Cancelled"),
                        ],
                        default="pending",
                        max_length=20,
                    ),
                ),
                ("placed_at", models.DateTimeField(auto_now_add=True)),
                ("total_price", models.DecimalField(decimal_places=2, max_digits=10)),
                ("address", models.TextField(default="Not Provided")),
                ("city", models.CharField(default="Not Provided", max_length=100)),
                ("state", models.CharField(default="Not Provided", max_length=100)),
                ("postal_code", models.CharField(default="000000", max_length=20)),
                ("country", models.CharField(default="Not Provided", max_length=100)),
            ],
        ),
        migrations.CreateModel(
            name="Shop",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("name", models.CharField(max_length=255)),
            ],
        ),
        migrations.CreateModel(
            name="User",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("email", models.EmailField(max_length=254, unique=True)),
                ("name", models.CharField(max_length=255)),
                (
                    "role",
                    models.CharField(
                        choices=[
                            ("buyer", "Buyer"),
                            ("seller", "Seller"),
                            ("admin", "Admin"),
                            ("courier", "Courier"),
                        ],
                        default="buyer",
                        max_length=10,
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="CartItem",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("quantity", models.PositiveIntegerField(default=1)),
                (
                    "book_listing",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="cart_items",
                        to="core.booklisting",
                    ),
                ),
                (
                    "cart",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="cart_items",
                        to="core.cart",
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="OrderAssignment",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("assigned_at", models.DateTimeField(auto_now_add=True)),
                (
                    "order",
                    models.OneToOneField(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="order_assignment",
                        to="core.order",
                    ),
                ),
                (
                    "courier",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="assigned_orders",
                        to="core.user",
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="DeliveryIssue",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("issue_description", models.TextField()),
                ("reported_at", models.DateTimeField(auto_now_add=True)),
                (
                    "order_assignment",
                    models.OneToOneField(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="delivery_issue",
                        to="core.orderassignment",
                    ),
                ),
            ],
        ),
        migrations.CreateModel(
            name="OrderItem",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("quantity", models.PositiveIntegerField(default=1)),
                (
                    "purchase_price",
                    models.DecimalField(decimal_places=2, max_digits=10),
                ),
                (
                    "book_listing",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="order_items",
                        to="core.booklisting",
                    ),
                ),
                (
                    "order",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="order_items",
                        to="core.order",
                    ),
                ),
            ],
        ),
        migrations.AddField(
            model_name="booklisting",
            name="shop",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="book_listings",
                to="core.shop",
            ),
        ),
        migrations.CreateModel(
            name="UpgradeRequest",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "target_role",
                    models.CharField(
                        choices=[
                            ("buyer", "Buyer"),
                            ("seller", "Seller"),
                            ("admin", "Admin"),
                            ("courier", "Courier"),
                        ],
                        max_length=10,
                    ),
                ),
                ("requested_at", models.DateTimeField(auto_now_add=True)),
                (
                    "user",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="upgrade_requests",
                        to="core.user",
                    ),
                ),
            ],
        ),
        migrations.AddField(
            model_name="shop",
            name="user",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="shops",
                to="core.user",
            ),
        ),
        migrations.CreateModel(
            name="Review",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "rating",
                    models.IntegerField(
                        choices=[(1, "1"), (2, "2"), (3, "3"), (4, "4"), (5, "5")]
                    ),
                ),
                ("comment", models.TextField()),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                (
                    "shop",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="reviews",
                        to="core.shop",
                    ),
                ),
                (
                    "user",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="reviews",
                        to="core.user",
                    ),
                ),
            ],
        ),
        migrations.AddField(
            model_name="order",
            name="user",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="orders",
                to="core.user",
            ),
        ),
        migrations.AddField(
            model_name="cart",
            name="user",
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name="carts",
                to="core.user",
            ),
        ),
    ]

</document_content>
</document>
<document index="41">
<source>.\core\migrations\0002_booklisting_descriptions.py</source>
<document_content>
# Generated by Django 5.1.5 on 2025-02-08 17:39

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0001_initial"),
    ]

    operations = [
        migrations.AddField(
            model_name="booklisting",
            name="descriptions",
            field=models.TextField(blank=True, null=True),
        ),
    ]

</document_content>
</document>
<document index="42">
<source>.\core\migrations\0003_orderassignment_updated_at.py</source>
<document_content>
# Generated by Django 5.1.5 on 2025-02-08 18:06

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0002_booklisting_descriptions"),
    ]

    operations = [
        migrations.AddField(
            model_name="orderassignment",
            name="updated_at",
            field=models.DateTimeField(auto_now=True),
        ),
    ]

</document_content>
</document>
<document index="43">
<source>.\core\migrations\0004_upgraderequest_approved_alter_order_status_and_more.py</source>
<document_content>
# Generated by Django 5.1.5 on 2025-02-09 20:05

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ("core", "0003_orderassignment_updated_at"),
    ]

    operations = [
        migrations.AddField(
            model_name="upgraderequest",
            name="approved",
            field=models.BooleanField(default=False),
        ),
        migrations.AlterField(
            model_name="order",
            name="status",
            field=models.CharField(
                choices=[
                    ("pending", "Pending"),
                    ("ready_to_ship", "Ready to Ship"),
                    ("shipped", "Shipped"),
                    ("completed", "Completed"),
                    ("cancelled", "Cancelled"),
                    ("issue_reported", "Issue Reported"),
                ],
                default="pending",
                max_length=20,
            ),
        ),
        migrations.AlterField(
            model_name="upgraderequest",
            name="target_role",
            field=models.CharField(
                choices=[
                    ("buyer", "Buyer"),
                    ("seller", "Seller"),
                    ("admin", "Admin"),
                    ("courier", "Courier"),
                    ("unassigned", "Unassigned"),
                ],
                max_length=10,
            ),
        ),
        migrations.AlterField(
            model_name="user",
            name="role",
            field=models.CharField(
                choices=[
                    ("buyer", "Buyer"),
                    ("seller", "Seller"),
                    ("admin", "Admin"),
                    ("courier", "Courier"),
                    ("unassigned", "Unassigned"),
                ],
                default="buyer",
                max_length=10,
            ),
        ),
    ]

</document_content>
</document>
<document index="44">
<source>.\core\migrations\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="45">
<source>.\core\models\__init__.py</source>
<document_content>
from .book_listing import BookListing
from .cart import Cart
from .cart_item import CartItem
from .delivery_issue import DeliveryIssue
from .order import Order
from .order_assignment import OrderAssignment
from .order_item import OrderItem
from .review import Review
from .shop import Shop
from .upgrade_request import UpgradeRequest
from .user import User

</document_content>
</document>
<document index="46">
<source>.\core\models\book_listing.py</source>
<document_content>
from django.db import models

from core.constants import CONDITION_CHOICES
from core.models.shop import Shop


class BookListing(models.Model):
    """
    Model representing a second-hand book listing in the marketplace.

    :ivar shop: ForeignKey linking the listing to a shop.
    :ivar title: Title of the book.
    :ivar author: Author of the book.
    :ivar condition: Condition of the book (NEW, GOOD, FAIR).
    :ivar price: Price of the book listing.
    :ivar image: ImageField for storing raw image files.
    :ivar bought: Boolean indicating whether the book has been purchased.
    """

    shop = models.ForeignKey(
        Shop, on_delete=models.CASCADE, related_name="book_listings"
    )
    title = models.CharField(max_length=255)
    author = models.CharField(max_length=255)
    condition = models.CharField(max_length=50, choices=CONDITION_CHOICES)
    price = models.DecimalField(max_digits=10, decimal_places=2)
    image = models.ImageField(upload_to="book_images/", null=True, blank=True)
    bought = models.BooleanField(default=False)
    descriptions = models.TextField(blank=True, null=True)

    def __str__(self):
        return self.title

</document_content>
</document>
<document index="47">
<source>.\core\models\cart.py</source>
<document_content>
from django.db import models

from core.models.user import User


class Cart(models.Model):
    """
    Represents a shopping cart associated with a user.

    The cart model stores items that a user intends to purchase. Each cart
    is linked to a specific user and tracks when it was created.

    :ivar user: ForeignKey linking the cart to a user.
    :ivar created_at: The timestamp indicating when the cart was created.
    """

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="carts")
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Cart {self.id} for {self.user.email}"

</document_content>
</document>
<document index="48">
<source>.\core\models\cart_item.py</source>
<document_content>
from django.core.exceptions import ValidationError
from django.db import models

from core.models.book_listing import BookListing
from core.models.cart import Cart


class CartItem(models.Model):
    """
    Represents an item in a shopping cart with associations to a cart and a book listing,
    along with a specified quantity.

    :ivar cart: ForeignKey linking the item to a shopping cart.
    :ivar book_listing: ForeignKey linking the item to a book listing.
    :ivar quantity: The number of the specific book in the cart.
    """

    cart = models.ForeignKey(Cart, on_delete=models.CASCADE, related_name="cart_items")
    book_listing = models.ForeignKey(
        BookListing, on_delete=models.CASCADE, related_name="cart_items"
    )
    quantity = models.PositiveIntegerField(default=1)

    def clean(self):
        """
        Validates the model's constraints before saving.

        This method ensures that the quantity of an item is greater than zero.
        If the quantity is zero or negative, a `ValidationError` is raised.

        :raises ValidationError: If `quantity` is less than or equal to zero.
        """
        if self.quantity <= 0:
            raise ValidationError({"quantity": "Quantity must be greater than zero."})

    def save(self, *args, **kwargs):
        """
        Saves the model instance after validation.

        This method overrides the default save behavior to ensure data integrity
        by calling the `clean` method before saving. It ensures that all
        validation checks are enforced before persisting the instance to the database.

        :param args: Positional arguments passed to the parent `save` method.
        :param kwargs: Keyword arguments passed to the parent `save` method.
        """
        self.clean()
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.quantity}x {self.book_listing.title} in Cart {self.cart.id}"

</document_content>
</document>
<document index="49">
<source>.\core\models\delivery_issue.py</source>
<document_content>
from django.db import models

from core.models.order_assignment import OrderAssignment


class DeliveryIssue(models.Model):
    """
    Represents an issue encountered during the delivery of an order.

    Each delivery issue is linked to an `OrderAssignment`, containing details
    about the problem reported and the timestamp of when it was logged.

    :ivar order_assignment: ForeignKey linking the issue to an order assignment.
    :ivar issue_description: A detailed description of the delivery issue.
    :ivar reported_at: The timestamp indicating when the issue was reported.
    """

    order_assignment = models.OneToOneField(
        OrderAssignment, on_delete=models.CASCADE, related_name="delivery_issue"
    )
    issue_description = models.TextField()
    reported_at = models.DateTimeField(auto_now_add=True)

    def __str__(self) -> str:
        return f"Issue for Order {self.order_assignment.order.id}: {self.issue_description[:50]}..."

</document_content>
</document>
<document index="50">
<source>.\core\models\order.py</source>
<document_content>
from django.db import models

from core.constants import STATUS_CHOICES
from core.models.user import User


class Order(models.Model):
    """
    Represents a purchase order made by a user.

    The `Order` model stores details about transactions, including the
    user who placed the order, its current status, the total price,
    the shipping address details, and the timestamp when it was placed.

    :ivar user: ForeignKey linking the order to a user.
    :ivar status: The status of the order (Pending, Completed, Cancelled).
    :ivar placed_at: The timestamp indicating when the order was placed.
    :ivar total_price: The total amount for the order.
    :ivar address: The street address for shipping.
    :ivar city: The city where the order is being shipped.
    :ivar state: The state or region for the shipping address.
    :ivar postal_code: The postal/zip code for shipping.
    :ivar country: The country where the order is being shipped.
    """

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="orders")
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="pending")
    placed_at = models.DateTimeField(auto_now_add=True)
    total_price = models.DecimalField(max_digits=10, decimal_places=2)

    # Address details
    address = models.TextField(default="Not Provided")
    city = models.CharField(max_length=100, default="Not Provided")
    state = models.CharField(max_length=100, default="Not Provided")
    postal_code = models.CharField(max_length=20, default="000000")
    country = models.CharField(max_length=100, default="Not Provided")

    def __str__(self):
        return f"Order {self.id} for {self.user.email} - {self.status}"

</document_content>
</document>
<document index="51">
<source>.\core\models\order_assignment.py</source>
<document_content>
from django.db import models

from core.models.order import Order
from core.models.user import User


class OrderAssignment(models.Model):
    """
    Represents the assignment of an order to a courier for delivery.

    This model links an Order to a courier (User) and records the assignment time.
    It also tracks the current delivery status and the last update time.

    :ivar order: OneToOneField linking the assignment to an order.
    :ivar courier: ForeignKey linking the assignment to a courier user.
    :ivar assigned_at: The timestamp when the order was assigned.
    :ivar updated_at: The timestamp when the assignment was last updated.
    """

    order = models.OneToOneField(
        Order, on_delete=models.CASCADE, related_name="order_assignment"
    )
    courier = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="assigned_orders"
    )
    assigned_at = models.DateTimeField(auto_now_add=True)

    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self) -> str:
        return f"Order {self.order.id} assigned to {self.courier.email} on {self.assigned_at}"

</document_content>
</document>
<document index="52">
<source>.\core\models\order_item.py</source>
<document_content>
from django.core.exceptions import ValidationError
from django.db import models

from core.models.book_listing import BookListing
from core.models.order import Order


class OrderItem(models.Model):
    """
    Represents an item inside an order.

    Each order item is linked to an `Order` and a `BookListing`, containing
    details about the quantity of books purchased and the price at which
    they were bought.

    :ivar order: ForeignKey linking the order item to an order.
    :ivar book_listing: ForeignKey linking the order item to a book listing.
    :ivar quantity: The number of copies of the book in the order.
    :ivar purchase_price: The price at which the book was purchased.
    """

    order = models.ForeignKey(
        Order, on_delete=models.CASCADE, related_name="order_items"
    )
    book_listing = models.ForeignKey(
        BookListing, on_delete=models.CASCADE, related_name="order_items"
    )
    quantity = models.PositiveIntegerField(default=1)
    purchase_price = models.DecimalField(max_digits=10, decimal_places=2)

    def clean(self) -> None:
        """
        Validates the model's constraints before saving.

        This method ensures that both `quantity` and `purchase_price` have valid values.
        - `quantity` must be greater than zero.
        - `purchase_price` must be greater than zero.

        If either value is invalid, a `ValidationError` is raised.

        :raises ValidationError: If `quantity` is less than or equal to zero.
        :raises ValidationError: If `purchase_price` is less than or equal to zero.
        """
        if self.quantity <= 0:
            raise ValidationError({"quantity": "Quantity must be greater than zero."})
        if self.purchase_price <= 0:
            raise ValidationError(
                {"purchase_price": "Purchase price must be greater than zero."}
            )

    def save(self, *args, **kwargs) -> None:
        """
        Saves the model instance after validation.

        This method overrides the default save behavior to ensure data integrity
        by calling the `clean` method before saving. It ensures that all
        validation checks are enforced before persisting the instance to the database.

        :param args: Positional arguments passed to the parent `save` method.
        :param kwargs: Keyword arguments passed to the parent `save` method.
        """
        self.clean()
        super().save(*args, **kwargs)

    def __str__(self) -> str:
        return f"{self.quantity}x {self.book_listing.title} in Order {self.order.id} - ${self.purchase_price}"

</document_content>
</document>
<document index="53">
<source>.\core\models\review.py</source>
<document_content>
from django.db import models

from core.constants import RATING_CHOICES
from core.models.shop import Shop
from core.models.user import User


class Review(models.Model):
    """
    Model representing a review for a shop.

    :ivar shop: ForeignKey linking the review to a shop.
    :ivar user: ForeignKey linking the review to a user.
    :ivar rating: IntegerField for the rating of the shop, restricted to a 1 to 5 scale.
    :ivar comment: TextField for additional feedback or remarks.
    :ivar created_at: DateTimeField automatically set to the timestamp when the review is created.
    """

    shop = models.ForeignKey(Shop, on_delete=models.CASCADE, related_name="reviews")
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="reviews")
    rating = models.IntegerField(choices=RATING_CHOICES)
    comment = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Review by {self.user.email} for {self.shop.name} - {self.rating}/5"

</document_content>
</document>
<document index="54">
<source>.\core\models\shop.py</source>
<document_content>
from django.db import models

from core.models.user import User


class Shop(models.Model):
    """
    Represents a shop owned by a user.

    The `Shop` model stores information about a seller's shop, including
    the shop's name and the user who owns it.

    :ivar name: The name of the shop.
    :ivar user: ForeignKey linking the shop to its owner.
    """

    name = models.CharField(max_length=255, null=False, blank=False)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name="shops")

    def __str__(self):
        return self.name

</document_content>
</document>
<document index="55">
<source>.\core\models\upgrade_request.py</source>
<document_content>
from django.db import models

from core.models.user import ROLE_CHOICES
from core.models.user import User


class UpgradeRequest(models.Model):
    """
    Represents a request by a user to upgrade their role.

    The `UpgradeRequest` model stores upgrade requests submitted by users
    who wish to change their roles (e.g., from buyer to seller). It tracks
    the requested role and the timestamp of the request.

    :ivar user: ForeignKey linking the upgrade request to the user making the request.
    :ivar target_role: The role that the user is requesting to upgrade to.
    :ivar requested_at: The timestamp indicating when the upgrade request was made.
    :ivar approved: Boolean indicating whether the upgrade request has been approved.
    """

    user = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="upgrade_requests"
    )
    target_role = models.CharField(max_length=10, choices=ROLE_CHOICES)
    requested_at = models.DateTimeField(auto_now_add=True)
    approved = models.BooleanField(default=False)

    def __str__(self):
        return f"Upgrade Request by {self.user.email} to {self.target_role}"

</document_content>
</document>
<document index="56">
<source>.\core\models\user.py</source>
<document_content>
from django.db import models

from core.constants import ROLE_CHOICES


class User(models.Model):
    """
    Represents a user in the system.

    This model defines the attributes and roles of users within the platform. Each user
    has a unique email, a name, and a specific role that determines their permissions
    and actions.

    :ivar email: A unique email address used for authentication and identification.
    :ivar name: The full name of the user.
    :ivar role: The role of the user within the system, chosen from predefined options
    """

    email = models.EmailField(unique=True, null=False, blank=False)
    name = models.CharField(max_length=255)
    role = models.CharField(max_length=10, choices=ROLE_CHOICES, default="buyer")

    def __str__(self):
        return self.email

</document_content>
</document>
<document index="57">
<source>.\core\templatetags\core_extras.py</source>
<document_content>
from django import template

register = template.Library()

@register.filter
def bootstrap_alert_class(message_tag):
    """Maps Django message tags to Bootstrap alert classes"""
    tag_map = {
        'debug': 'info',
        'info': 'info',
        'success': 'success',
        'warning': 'warning',
        'error': 'danger'
    }
    return f"alert-{tag_map.get(message_tag, 'info')}"
</document_content>
</document>
<document index="58">
<source>.\core\utils\__init__.py</source>
<document_content>
from .decorators import *

</document_content>
</document>
<document index="59">
<source>.\core\utils\decorators.py</source>
<document_content>
from django.http import HttpResponseForbidden
from functools import wraps
from core.constants import ROLE_CHOICES
from core.models.user import User as CustomUser


def allowed_roles(roles):
    """
    Restricts access to views based on user roles.

    This decorator checks if the authenticated user has one of the specified roles
    before allowing access to the decorated view. It works with the custom User model's
    role field, which can be one of the roles defined in the ROLE_CHOICES list in core/constants.py.

    :param roles: A list of role names that are allowed to access the view. Must match the role choices defined in ROLE_CHOICES.
    :return: A decorated view function that includes role-based access control
    :raises: HttpResponseForbidden if the user is not authenticated or doesn't have the required role
    :raises: ValueError if any of the specified roles are not valid according to ROLE_CHOICES

    Example::

        @allowed_roles(['seller', 'admin'])
        def seller_dashboard(request):
            # Only users with 'seller' or 'admin' roles can access this view
            pass
    """

    # Validate that all specified roles are valid
    valid_roles = [role[0] for role in ROLE_CHOICES]
    for role in roles:
        if role not in valid_roles:
            raise ValueError(
                f"Invalid role: {role}. Valid roles are: {', '.join(valid_roles)}"
            )

    def decorator(view_func):
        @wraps(view_func)
        def wrapper(request, *args, **kwargs):
            if not request.user.is_authenticated:
                return HttpResponseForbidden(
                    "You must be logged in to access this page."
                )

            try:
                custom_user = CustomUser.objects.get(email=request.user.email)
                if custom_user.role not in roles:
                    allowed_roles_str = ", ".join(roles)
                    return HttpResponseForbidden(
                        f"Access denied. This page requires one of the following roles: {allowed_roles_str}. "
                        f"Your current role is: {custom_user.role}"
                    )
                return view_func(request, *args, **kwargs)
            except CustomUser.DoesNotExist:
                return HttpResponseForbidden(
                    "Custom user not found. This is a system error - please contact support."
                )

        return wrapper

    return decorator

</document_content>
</document>
<document index="60">
<source>.\courier\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="61">
<source>.\courier\admin.py</source>
<document_content>
from django.contrib import admin

# Register your models here.

</document_content>
</document>
<document index="62">
<source>.\courier\apps.py</source>
<document_content>
from django.apps import AppConfig


class CourierConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "courier"

</document_content>
</document>
<document index="63">
<source>.\courier\models.py</source>
<document_content>
from django.db import models

# Create your models here.

</document_content>
</document>
<document index="64">
<source>.\courier\tests.py</source>
<document_content>
from django.test import TestCase

# Create your tests here.

</document_content>
</document>
<document index="65">
<source>.\courier\urls.py</source>
<document_content>
from django.urls import path
from .views import deliveries_page, accept_order, update_assignment, report_issue
from courier.views.profile import profile_page

urlpatterns = [
    path("deliveries/", deliveries_page, name="courier-deliveries"),
    path("accept/<int:order_id>/", accept_order, name="courier-accept-order"),
    path(
        "update/<int:assignment_id>/",
        update_assignment,
        name="courier-update-assignment",
    ),
    path("report/<int:assignment_id>/", report_issue, name="courier-report-issue"),
    path("profile/", profile_page, name="courier-profile"),
]

</document_content>
</document>
<document index="66">
<source>.\courier\migrations\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="67">
<source>.\courier\views\__init__.py</source>
<document_content>
from .deliveries import deliveries_page, accept_order, update_assignment, report_issue

</document_content>
</document>
<document index="68">
<source>.\courier\views\deliveries.py</source>
<document_content>
"""
Views for managing courier deliveries.
"""

from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, redirect, get_object_or_404
from django.urls import reverse
from core.models.delivery_issue import DeliveryIssue
from core.models.order import Order
from core.models.order_assignment import OrderAssignment
from core.models.user import User
from core.utils.decorators import allowed_roles


@login_required
@allowed_roles(["courier"])
def deliveries_page(request):
    """
    Renders a page showing available orders (ready to ship with no assignment)
    and the logged-in courier's assignments.
    """
    # Try to get the email from request.user; if not present, assume request.user is the email string.
    try:
        user_email = request.user.email
    except AttributeError:
        user_email = request.user  # Fallback if request.user is a string

    # Retrieve the proper User instance using the email.
    current_user = get_object_or_404(User, email=user_email)

    # Available orders: orders that are ready_to_ship and have no assignment.
    available_orders = Order.objects.filter(
        status="ready_to_ship", order_assignment__isnull=True
    ).order_by("-placed_at")

    # My deliveries: order assignments for which the courier is the logged-in user.
    my_assignments = OrderAssignment.objects.filter(courier=current_user).order_by(
        "-updated_at"
    )

    context = {
        "pending_orders": available_orders,  # Keep the template variable name for now
        "my_assignments": my_assignments,
    }
    return render(request, "courier/deliveries.html", context)


@login_required
@allowed_roles(["courier"])
def accept_order(request, order_id):
    """
    Handles accepting an order. Creates an OrderAssignment for the order
    and updates its status to 'shipped'.
    """
    order = get_object_or_404(
        Order, id=order_id, status="ready_to_ship", order_assignment__isnull=True
    )

    # Retrieve a proper User instance using the email from request.user
    try:
        user_email = request.user.email
    except AttributeError:
        user_email = request.user  # Fallback if request.user is a string
    current_user = get_object_or_404(User, email=user_email)

    OrderAssignment.objects.create(order=order, courier=current_user)
    order.status = "shipped"
    order.save()
    return redirect(reverse("courier-deliveries"))


@login_required
@allowed_roles(["courier"])
def update_assignment(request, assignment_id):
    """
    Handles updating an existing assignment.
    If the action is 'unaccept', it deletes the assignment and sets the order status to 'ready_to_ship'.
    If the action is 'complete', it updates the order status to 'completed'.
    """
    # Retrieve a proper User instance using request.user.email, similar to the buyer view
    try:
        user_email = request.user.email
    except AttributeError:
        user_email = request.user  # fallback if request.user is a string

    current_user = get_object_or_404(User, email=user_email)

    # Query the assignment ensuring the courier is the proper user instance.
    assignment = get_object_or_404(
        OrderAssignment, id=assignment_id, courier=current_user
    )

    if request.method == "POST":
        action = request.POST.get("action")
        order = assignment.order
        if action == "unaccept":
            assignment.delete()
            order.status = "ready_to_ship"
            order.save()
        elif action == "complete":
            order.status = "completed"
            order.save()
    return redirect(reverse("courier-deliveries"))


@login_required
@allowed_roles(["courier"])
def report_issue(request, assignment_id):
    """
    Renders a form for a courier to report an issue with an order assignment.
    On POST, creates or updates the DeliveryIssue.
    Displays a success message when the issue is reported.

    :param request: Django HttpRequest object.
    :param assignment_id: The ID of the OrderAssignment to report an issue for.
    :return: Renders the report issue page on GET, or redirects to the deliveries page on POST.
    """
    # Retrieve a proper User instance using the email from request.user
    try:
        user_email = request.user.email
    except AttributeError:
        user_email = request.user  # Fallback if request.user is a string
    current_user = get_object_or_404(User, email=user_email)

    # Ensure that the assignment belongs to the current courier.
    assignment = get_object_or_404(
        OrderAssignment, id=assignment_id, courier=current_user
    )

    if request.method == "POST":
        issue_description = request.POST.get("issue_description", "").strip()
        if not issue_description:
            messages.error(request, "Please provide a description for the issue.")
            return redirect(reverse("courier-report-issue", args=[assignment_id]))

        # Create or update the DeliveryIssue for this assignment.
        delivery_issue, created = DeliveryIssue.objects.get_or_create(
            order_assignment=assignment
        )
        delivery_issue.issue_description = issue_description
        delivery_issue.save()

        messages.success(request, "Issue reported successfully!")
        return redirect(reverse("courier-deliveries"))

    # Try to get existing delivery issue
    try:
        delivery_issue = DeliveryIssue.objects.get(order_assignment=assignment)
        existing_description = delivery_issue.issue_description
    except DeliveryIssue.DoesNotExist:
        existing_description = ""

    context = {"assignment": assignment, "existing_description": existing_description}
    return render(request, "courier/report_issue.html", context)

</document_content>
</document>
<document index="69">
<source>.\courier\views\profile.py</source>
<document_content>
from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from core.models.user import User as CustomUser
from core.utils.decorators import allowed_roles


@login_required
@allowed_roles(["courier"])
def profile_page(request):
    custom_user = CustomUser.objects.get(email=request.user.email)

    context = {
        "name": custom_user.name,
        "username": request.user.username,
        "email": request.user.email,
    }

    return render(request, "courier/profile.html", context)

</document_content>
</document>
<document index="70">
<source>.\portal_admin\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="71">
<source>.\portal_admin\admin.py</source>
<document_content>
from django.contrib import admin

# Register your models here.

</document_content>
</document>
<document index="72">
<source>.\portal_admin\apps.py</source>
<document_content>
from django.apps import AppConfig


class AdminConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "portal_admin"

</document_content>
</document>
<document index="73">
<source>.\portal_admin\models.py</source>
<document_content>
from django.db import models

# Create your models here.

</document_content>
</document>
<document index="74">
<source>.\portal_admin\tests.py</source>
<document_content>
from django.test import TestCase

# Create your tests here.

</document_content>
</document>
<document index="75">
<source>.\portal_admin\urls.py</source>
<document_content>

</document_content>
</document>
<document index="76">
<source>.\portal_admin\migrations\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="77">
<source>.\portal_admin\views\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="78">
<source>.\seller\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="79">
<source>.\seller\admin.py</source>
<document_content>
from django.contrib import admin

# Register your models here.

</document_content>
</document>
<document index="80">
<source>.\seller\apps.py</source>
<document_content>
from django.apps import AppConfig


class SellerConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "seller"

</document_content>
</document>
<document index="81">
<source>.\seller\models.py</source>
<document_content>
from django.db import models

# Create your models here.

</document_content>
</document>
<document index="82">
<source>.\seller\tests.py</source>
<document_content>
from django.test import TestCase

# Create your tests here.

</document_content>
</document>
<document index="83">
<source>.\seller\urls.py</source>
<document_content>
from django.urls import path

from seller.views import *
from .views.orders import orders_page, mark_order_ready

urlpatterns = [
    path("book-listings/", book_listings_page, name="seller-book-listings"),
    path("book-listings/add/", add_book_listing, name="seller-add-book"),
    path(
        "book-listings/delete/<int:listing_id>/",
        delete_book_listing,
        name="seller-delete-book",
    ),
    path(
        "book-listings/edit/<int:listing_id>/",
        edit_book_listing,
        name="seller-edit-book",
    ),
    path("profile/", profile_page, name="seller-profile"),
    path("update-shop-name/", update_shop_name, name="update-shop-name"),
    path("orders/", orders_page, name="seller-orders"),
    path("orders/<int:order_id>/ready/", mark_order_ready, name="mark-order-ready"),
    path("dashboard/", seller_dashboard, name="seller-dashboard"),
]

</document_content>
</document>
<document index="84">
<source>.\seller\migrations\__init__.py</source>
<document_content>

</document_content>
</document>
<document index="85">
<source>.\seller\templatetags\__init__.py</source>
<document_content>
# This file allows Django to recognize 'templatetags' as a package

</document_content>
</document>
<document index="86">
<source>.\seller\templatetags\custom_filters.py</source>
<document_content>
from django import template

register = template.Library()


@register.filter
def replace_underscores(value):
    """Replaces underscores with spaces in status text"""
    if isinstance(value, str):
        return value.replace("_", " ")
    return value


@register.filter
def mul(value, arg):
    """Multiplies the given value by an argument and returns the result as a float."""
    try:
        return float(value) * float(arg)
    except (ValueError, TypeError):
        return ""


@register.filter
def div(value, arg):
    """Divides the given value by an argument and returns the result as a float."""
    try:
        return float(value) / float(arg)
    except (ValueError, TypeError, ZeroDivisionError):
        return ""

</document_content>
</document>
<document index="87">
<source>.\seller\views\__init__.py</source>
<document_content>
from .dashboard import seller_dashboard
from .orders import orders_page
from .book_listings import add_book_listing
from .book_listings import book_listings_page, delete_book_listing, edit_book_listing
from .profile import profile_page
from .update_shop_name import update_shop_name

</document_content>
</document>
<document index="88">
<source>.\seller\views\book_listings.py</source>
<document_content>
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, redirect, get_object_or_404
import os

from core.constants import CONDITION_CHOICES
from core.models.book_listing import BookListing
from core.models.shop import Shop
from core.utils.decorators import allowed_roles


def is_valid_image(image):
    """Helper function to validate image file type."""
    if not image:
        return True  # Image is optional

    valid_extensions = [".jpg", ".jpeg", ".png"]
    ext = os.path.splitext(image.name)[1].lower()
    return ext in valid_extensions


@login_required
@allowed_roles(["seller"])
def book_listings_page(request):
    """
    Displays all book listings (that are not bought) for the logged-in seller.
    Also avoids duplicating the "No shop found..." message if it was already set.
    """
    current_user = request.user
    shop = Shop.objects.filter(user__email=current_user.email).first()

    if not shop:
        # Check if "No shop found" was already in the messages queue
        existing_msgs = [m.message for m in messages.get_messages(request)]
        if not any("No shop found for this seller" in msg for msg in existing_msgs):
            messages.error(
                request, "No shop found for this seller. Please set up your shop first."
            )
        listings = []
    else:
        listings = BookListing.objects.filter(shop=shop, bought=False)

    context = {
        "listings": listings,
        "CONDITION_CHOICES": CONDITION_CHOICES,
    }
    return render(request, "seller/book_listings.html", context)


@login_required
@allowed_roles(["seller"])
def add_book_listing(request):
    """
    Displays a form for adding a new book listing. On POST, creates a new listing
    and redirects back to the book listings page with a success message.
    """
    current_user = request.user
    shop = Shop.objects.filter(user__email=current_user.email).first()
    if not shop:
        messages.error(
            request, "No shop found for this seller. Please set up your shop first."
        )
        return redirect("seller-book-listings")

    if request.method == "POST":
        title = request.POST.get("title", "").strip()
        author = request.POST.get("author", "").strip()
        condition = request.POST.get("condition")
        price = request.POST.get("price")
        image = request.FILES.get("image")  # may be None

        if not (title and author and condition and price):
            messages.error(request, "Please fill in all required fields.")
        elif image and not is_valid_image(image):
            messages.warning(request, "Please upload only JPG or PNG image files.")
        else:
            try:
                price_val = float(price)
            except ValueError:
                messages.warning(request, "Price must be a valid number.")
            else:
                if price_val < 0:
                    messages.warning(request, "Price cannot be negative.")
                else:
                    try:
                        BookListing.objects.create(
                            shop=shop,
                            title=title,
                            author=author,
                            condition=condition,
                            price=price_val,
                            image=image,  # image is optional
                        )
                        messages.success(request, "Book listing added successfully!")
                        return redirect("seller-book-listings")
                    except Exception:
                        messages.warning(
                            request, "Failed to add book listing. Please try again."
                        )

    # On GET, render the add book listing page.
    context = {
        "CONDITION_CHOICES": CONDITION_CHOICES,
    }
    return render(request, "seller/add_book_listing.html", context)


@login_required
@allowed_roles(["seller"])
def delete_book_listing(request, listing_id):
    """
    Deletes a book listing for the seller after confirmation.
    """
    current_user = request.user
    shop = Shop.objects.filter(user__email=current_user.email).first()
    listing = get_object_or_404(BookListing, id=listing_id, shop=shop)
    if request.method == "POST":
        listing.delete()
        messages.success(request, "Book listing deleted successfully!")
    else:
        messages.error(request, "Invalid request.")
    return redirect("seller-book-listings")


@login_required
@allowed_roles(["seller"])
def edit_book_listing(request, listing_id):
    """
    Displays a form pre-populated with the details of the specified book listing.
    On POST, updates the book listing in the database.
    """
    current_user = request.user
    shop = Shop.objects.filter(user__email=current_user.email).first()
    if not shop:
        messages.error(
            request, "No shop found for this seller. Please set up your shop first."
        )
        return redirect("seller-book-listings")

    listing = get_object_or_404(BookListing, id=listing_id, shop=shop)

    if request.method == "POST":
        title = request.POST.get("title", "").strip()
        author = request.POST.get("author", "").strip()
        condition = request.POST.get("condition")
        price = request.POST.get("price")
        image = request.FILES.get("image")  # may be None

        if not (title and author and condition and price):
            messages.error(request, "Please fill in all required fields.")
        elif image and not is_valid_image(image):
            messages.warning(request, "Please upload only JPG or PNG image files.")
        else:
            try:
                price_val = float(price)
            except ValueError:
                messages.error(request, "Price must be a valid number.")
            else:
                if price_val < 0:
                    messages.error(request, "Price cannot be negative.")
                else:
                    try:
                        listing.title = title
                        listing.author = author
                        listing.condition = condition
                        listing.price = price_val
                        if image:
                            listing.image = (
                                image  # update image only if a new one is provided
                            )
                        listing.save()
                        messages.success(request, "Book listing updated successfully!")
                        return redirect("seller-book-listings")
                    except Exception:
                        messages.error(
                            request, "Failed to update book listing. Please try again."
                        )

    context = {
        "listing": listing,
        "CONDITION_CHOICES": CONDITION_CHOICES,
    }
    return render(request, "seller/edit_book_listing.html", context)

</document_content>
</document>
<document index="89">
<source>.\seller\views\dashboard.py</source>
<document_content>
from django.contrib.auth.decorators import login_required
from django.db.models import Sum, F, DecimalField
from django.shortcuts import render
from core.models.order import Order
from core.models.order_item import OrderItem
from core.models.user import User as CustomUser


@login_required
def seller_dashboard(request):
    """
    Renders the seller dashboard with statistics and recent orders for the logged-in seller.
    """
    # Get the custom user model instance for the logged-in user
    custom_user = CustomUser.objects.get(email=request.user.email)

    # Get all order items for the current seller's listings
    seller_order_items = OrderItem.objects.filter(book_listing__shop__user=custom_user)

    # Get completed order items for revenue calculation
    completed_order_items = seller_order_items.filter(order__status="completed")

    # Calculate total revenue (80% of sales)
    total_revenue = (
        completed_order_items.aggregate(
            revenue=Sum(
                F("quantity") * F("purchase_price") * 0.8,
                output_field=DecimalField(max_digits=10, decimal_places=2),
            )
        )["revenue"]
        or 0
    )

    # Count total orders (distinct orders containing seller's items)
    total_orders = seller_order_items.values("order").distinct().count()

    # Count pending orders
    pending_orders = (
        seller_order_items.filter(order__status="pending")
        .values("order")
        .distinct()
        .count()
    )

    # Count total books sold
    books_sold = completed_order_items.aggregate(total=Sum("quantity"))["total"] or 0

    # Get recent orders containing seller's items
    recent_orders = (
        Order.objects.filter(order_items__book_listing__shop__user=custom_user)
        .distinct()
        .order_by("-placed_at")[:5]
    )

    context = {
        "total_orders": total_orders,
        "total_revenue": total_revenue,
        "pending_orders": pending_orders,
        "books_sold": books_sold,
        "recent_orders": recent_orders,
    }

    return render(request, "seller/dashboard.html", context)

</document_content>
</document>
<document index="90">
<source>.\seller\views\orders.py</source>
<document_content>
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, redirect, get_object_or_404
from core.models.order import Order
from core.models.order_assignment import OrderAssignment
from core.utils.decorators import allowed_roles


@login_required
@allowed_roles(["seller"])
def orders_page(request):
    """Renders a page displaying all orders placed by buyers."""
    all_orders = Order.objects.all().order_by("-placed_at")  # Fetch all orders
    assigned_orders = OrderAssignment.objects.values_list(
        "order_id", flat=True
    )  # Get assigned orders

    context = {"orders": all_orders, "assigned_orders": assigned_orders}
    return render(request, "seller/orders.html", context)


@login_required
@allowed_roles(["seller"])
def mark_order_ready(request, order_id):
    """Toggles order status between 'Pending' and 'Ready to Ship' unless courier accepted it."""
    if request.method == "POST":
        order = get_object_or_404(Order, id=order_id)

        # Prevent modification if courier has already accepted
        if OrderAssignment.objects.filter(order=order).exists():
            return redirect("seller-orders")

        # Toggle logic: 'Pending'  'Ready to Ship', 'Ready to Ship'  'Pending'
        if order.status == "pending":
            order.status = "ready_to_ship"
        elif order.status == "ready_to_ship":
            order.status = "pending"

        order.save()
        return redirect("seller-orders")

    return redirect("seller-orders")

</document_content>
</document>
<document index="91">
<source>.\seller\views\profile.py</source>
<document_content>
from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from core.models.user import User as CustomUser
from core.utils.decorators import allowed_roles


@login_required
@allowed_roles(["seller"])
def profile_page(request):
    custom_user = CustomUser.objects.get(email=request.user.email)
    shop = custom_user.shops.get()

    context = {
        "name": custom_user.name,
        "shop_name": shop.name,
        "username": request.user.username,
        "email": request.user.email,
    }

    return render(request, "seller/profile.html", context)

</document_content>
</document>
<document index="92">
<source>.\seller\views\update_shop_name.py</source>
<document_content>
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from core.models.user import User as CustomUser
from auths.views import _redirect_to_profile
from core.utils.decorators import allowed_roles


@login_required
@allowed_roles(["seller"])
def update_shop_name(request):
    custom_user = CustomUser.objects.get(email=request.user.email)
    shop = custom_user.shops.get()

    if request.method != "POST":
        return _redirect_to_profile(custom_user)

    new_shop_name = request.POST.get("new_shop_name")

    if not new_shop_name:
        messages.error(request, "Please provide a new shop name")
        return _redirect_to_profile(custom_user)

    try:
        shop.name = new_shop_name
        shop.save()

        messages.success(request, "Shop name updated successfully")
        return _redirect_to_profile(custom_user)
    except Exception as e:
        messages.error(request, f"Failed to update shop name: {str(e)}")
        return _redirect_to_profile(custom_user)

</document_content>
</document>
</documents>
